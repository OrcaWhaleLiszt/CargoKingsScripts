-- ClientPlaneInput.lua (v4.2-min — Default Roblox Camera, no custom camera code)
-- Put this LocalScript in: StarterPlayer > StarterPlayerScripts
--
-- NOTE:
-- • This version intentionally does NOT touch the camera at all.
-- • No Scriptable camera, no smoothing, no manual CFrame. Roblox default only.
-- • Physics update still runs locally to test jitter vs camera.

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local GuiService = game:GetService("GuiService")
local Workspace = game:GetService("Workspace")

-- ===== DEVICE DETECTION =====
local player = Players.LocalPlayer
local mouse = player:GetMouse()
local playerGui = player:WaitForChild("PlayerGui")

local isMobile = UserInputService.TouchEnabled and not UserInputService.MouseEnabled
local isDesktop = not isMobile and UserInputService.MouseEnabled

-- ===== REMOTES =====
local remoteFolder = ReplicatedStorage:WaitForChild("PlaneRemotes", 10)
if not remoteFolder then warn("❌ PlaneRemotes folder not found!"); return end

local inputRemote          = remoteFolder:WaitForChild("PlaneInput", 5)           -- kept for compatibility
local activateRemote       = remoteFolder:WaitForChild("PlaneActivate", 5)
local throttleRemote       = remoteFolder:WaitForChild("ThrottleUpdate", 5)
local gearToggleRemote     = remoteFolder:WaitForChild("RE_GearToggle", 5)
local throttleSyncRemote   = remoteFolder:WaitForChild("RE_ThrottleSync", 5)
local crashRemote          = remoteFolder:WaitForChild("PlaneCrash", 5)

if not (inputRemote and activateRemote and throttleRemote and gearToggleRemote and throttleSyncRemote and crashRemote) then
	warn("❌ Failed to find all plane remotes!")
	return
end

-- ===== GUI (Throttle / Brake / Fuel Range) =====
local gui = Instance.new("ScreenGui")
gui.Name = "PlaneIndicators"
gui.ResetOnSpawn = false
gui.Enabled = false
gui.Parent = playerGui

local function mkBar(xOffset)
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0, 26, 0, 0)
	frame.Position = UDim2.new(0, xOffset, 1, -20)
	frame.AnchorPoint = Vector2.new(0, 1)
	frame.BackgroundTransparency = 0.3
	frame.BorderSizePixel = 0
	frame.Parent = gui
	Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8)
	return frame
end

local rangeBar = Instance.new("Frame")
rangeBar.Size = UDim2.new(0, 26, 0, 300)
rangeBar.Position = UDim2.new(0, 20, 1, -20)
rangeBar.AnchorPoint = Vector2.new(0, 1)
rangeBar.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
rangeBar.BackgroundTransparency = 0.3
rangeBar.BorderSizePixel = 0
rangeBar.Parent = gui
Instance.new("UICorner", rangeBar).CornerRadius = UDim.new(0, 8)

local throttleBar = mkBar(56)
throttleBar.BackgroundColor3 = Color3.fromRGB(255,255,255)

local brakeBar = mkBar(56)
brakeBar.BackgroundColor3 = Color3.fromRGB(255, 60, 60)
brakeBar.Visible = false

-- ===== MOBILE HUD (Buttons) =====
local mobileHud = Instance.new("ScreenGui")
mobileHud.Name = "PlaneMobileHUD"
mobileHud.ResetOnSpawn = false
mobileHud.Enabled = false
mobileHud.Parent = playerGui

local function mkButton(name, anchor, pos, size, text)
	local b = Instance.new("TextButton")
	b.Name = name
	b.AnchorPoint = anchor
	b.Position = pos
	b.Size = size
	b.Text = text
	b.TextScaled = true
	b.BackgroundTransparency = 0.2
	b.BackgroundColor3 = Color3.fromRGB(30,30,30)
	b.TextColor3 = Color3.new(1,1,1)
	b.AutoButtonColor = true
	b.Parent = mobileHud
	local corner = Instance.new("UICorner", b)
	corner.CornerRadius = UDim.new(0,12)
	return b
end

local throttleUpBtn   = mkButton("ThrottleUp",   Vector2.new(0,1), UDim2.new(0,20, 1,-90), UDim2.new(0,80, 0,80), "▲")
local throttleDownBtn = mkButton("ThrottleDown", Vector2.new(0,1), UDim2.new(0,20, 1,-5),  UDim2.new(0,80, 0,80), "▼")
local gearBtn         = mkButton("Gear", Vector2.new(1,0), UDim2.new(1,-20, 0, 20), UDim2.new(0,120, 0,60), "Gear")

-- ===== STATE =====
local currentSeat, currentPlane
local currentPlaneData = nil -- client-side plane data ('pd')
local flying = false

local keys = {
	landing = {key = "g", down = false},
	spdup   = {down = false},
	spddwn  = {down = false}
}

local currentThrottle, currentBrake, targetThrottle, targetBrake = 0,0,0,0
local currentRange, targetRange = 1,1

-- Gamepad/touch look state (used by mobile getAim)
local gpRightX, gpRightY = 0, 0
local gpHaveRecentLook = false
local gpLookDecay = 0.9

local touchLookId = nil
local touchLookVec = Vector2.new()
local haveRecentTouchLook = false

-- ========================================================
-- HELPER FUNCTIONS (copied from server where needed)
-- ========================================================
local function mkSound(main, name, id, minVol, minPitch, rolloff)
	if not id then return nil end
	local s = Instance.new("Sound")
	s.Name = name
	s.SoundId = id
	s.RollOffMode = Enum.RollOffMode.Linear
	s.RollOffMaxDistance = rolloff or 200
	s.Looped = true
	s.Volume = minVol or 0
	s.Pitch = minPitch or 1
	s.Parent = main
	return s
end

local function setupGearParts(landingGearInstance)
	local gearParts = {}
	local function getGear(p)
		for _,v in ipairs(p:GetChildren()) do
			if v:IsA("BasePart") then
				if not v:FindFirstChild("Trans") then
					local t = Instance.new("NumberValue", v); t.Name="Trans"; t.Value=v.Transparency
					local r = Instance.new("NumberValue", v); r.Name="Ref"; r.Value=v.Reflectance
					local c = Instance.new("BoolValue", v);  c.Name="Collide"; c.Value=v.CanCollide
				end
				table.insert(gearParts, v)
			end
			getGear(v)
		end
	end
	getGear(landingGearInstance)
	return gearParts
end

local function getLowestPoint(main, gearParts)
	local lowestPoint = 0
	if #gearParts == 0 then
		lowestPoint = (main.Position.Y + 5 + (main.Size.Y/2))
	else
		for _,v in ipairs(gearParts) do
			local _0 = (main.Position.Y-(v.CFrame*CFrame.new((v.Size.X/2),0,0)).Y)
			local _1 = (main.Position.Y-(v.CFrame*CFrame.new(-(v.Size.X/2),0,0)).Y)
			local _2 = (main.Position.Y-(v.CFrame*CFrame.new(0,(v.Size.Y/2),0)).Y)
			local _3 = (main.Position.Y-(v.CFrame*CFrame.new(0,-(v.Size.Y/2),0)).Y)
			local _4 = (main.Position.Y-(v.CFrame*CFrame.new(0,0,(v.Size.Z/2))).Y)
			local _5 = (main.Position.Y-(v.CFrame*CFrame.new(0,0,-(v.Size.Z/2))).Y)
			local n = (math.max(_0,_1,_2,_3,_4,_5)+5)
			if n > lowestPoint then lowestPoint = n end
		end
	end
	return lowestPoint
end

local function calculateTransition(speed, transStart, transEnd)
	if speed <= transStart then return 0 end
	if speed >= transEnd then return 1 end
	if (transEnd - transStart) == 0 then return 1 end
	return (speed - transStart) / (transEnd - transStart)
end

local function isTaxiing(pd)
	local onGround = Workspace:FindPartOnRay(Ray.new(pd.main.Position, Vector3.new(0, -pd.lowestPoint, 0)), pd.plane)
	return onGround and pd.currentSpeed <= pd.cfg.STALL_SPEED
end

local function stall(pd)
	if pd.isBraking and pd.desiredSpeed < pd.cfg.STALL_SPEED then return false end
	local diff = ((pd.realSpeed - pd.cfg.STALL_SPEED) / 200)
	diff = (diff > 0.9 and 0.9 or diff)
	local check = {
		(pd.currentSpeed <= pd.cfg.STALL_SPEED),
		(pd.main.CFrame.lookVector.Y > (pd.realSpeed < pd.cfg.STALL_SPEED and -1 or diff))
	}
	for _, c in ipairs(check) do if not c then return false end end
	return true
end

-- ===== Aim (Desktop = mouse; Mobile/Console = virtual look)
local function getAim()
	if isDesktop then
		return mouse.X, mouse.Y, mouse.ViewSizeX, mouse.ViewSizeY, mouse.Hit, mouse.Hit.p
	end

	local cam = workspace.CurrentCamera
	local origin = cam.CFrame.Position
	local vx, vy = 0, 0
	if haveRecentTouchLook then
		vx, vy = touchLookVec.X, touchLookVec.Y
	elseif gpHaveRecentLook then
		vx, vy = gpRightX, gpRightY
	end

	local lookCF = cam.CFrame
	local yaw   = vx * 0.7
	local pitch = -vy * 0.5
	local aimCF = lookCF * CFrame.Angles(0, yaw, 0) * CFrame.Angles(pitch, 0, 0)
	local dir = aimCF.LookVector * 500

	local ray = Ray.new(origin, dir)
	local hitPart, hitPos = workspace:FindPartOnRay(ray, player.Character, false, true)
	local fallbackPos = origin + dir
	local hitCFrame = CFrame.new(fallbackPos)
	if hitPart then
		hitCFrame = CFrame.new(hitPos)
	end

	local vp = cam.ViewportSize
	local cx, cy = math.floor(vp.X/2), math.floor(vp.Y/2)
	return cx, cy, vp.X, vp.Y, hitCFrame, hitCFrame.Position
end

-- ========================================================
-- LOCAL PHYSICS UPDATE (entire v4.2 logic, runs client-side)
-- ========================================================
local crashDetectionState = {
	wasHighSpeed = false,
	suddenDropTime = 0,
	crashPending = false
}

local function update(pd, input, dt)
	if not pd.on or not pd.player then return end
	if not (input and input.viewSizeX and input.mouseX and input.mouseHit and input.mouseHitP) then return end

	local cfg = pd.cfg
	if dt <= 0 then return end

	local dist = (pd.lastPos - pd.main.Position).Magnitude
	pd.realSpeed = (dist / dt)
	pd.lastPos = pd.main.Position

	-- Crash detect (speed drop)
	local crashThreshold = cfg.CRASH_SPEED_THRESHOLD or 150
	local now = tick()
	if pd.realSpeed >= crashThreshold then
		crashDetectionState.wasHighSpeed = true
		crashDetectionState.suddenDropTime = 0
		crashDetectionState.crashPending = false
	end
	if crashDetectionState.wasHighSpeed and pd.realSpeed <= (crashThreshold * 0.1) then
		if crashDetectionState.suddenDropTime == 0 then
			crashDetectionState.suddenDropTime = now
			crashDetectionState.crashPending = true
		elseif crashDetectionState.crashPending and (now - crashDetectionState.suddenDropTime) >= 0.5 then
			print(("💥 CRASH DETECTED! Speed dropped from %d to %.1f"):format(crashThreshold, pd.realSpeed))
			if crashRemote then
				print("🔥 Firing crash remote to server...")
				crashRemote:FireServer(pd.plane)
			end
			crashDetectionState.wasHighSpeed = false
			crashDetectionState.suddenDropTime = 0
			crashDetectionState.crashPending = false
			pd.on = false
			return
		end
	elseif pd.realSpeed > (crashThreshold * 0.1) then
		if crashDetectionState.crashPending then
			crashDetectionState.crashPending = false
			crashDetectionState.suddenDropTime = 0
		end
	end

	-- Void safeguard
	if pd.main.Position.Y < cfg.VOID_THRESHOLD then
		pd.main.CFrame = CFrame.new(pd.main.Position.X, 50, pd.main.Position.Z)
		pd.main.AssemblyLinearVelocity = Vector3.new(0, -10, 0)
		print("⚠️ VOID PREVENTION - Teleported to safety!")
	end

	local transitionFactor = calculateTransition(pd.currentSpeed, cfg.TRANSITION_START, cfg.TRANSITION_END)

	-- Fuel (server owns drain; client mirrors GUI target)
	pd.fuelRange = targetRange
	if pd.fuelRange <= 0 then
		pd.throttle = 0
	end

	-- Throttle & brake
	if input.throttleUp then
		if pd.brakeThrottle > 0 then
			pd.brakeThrottle = math.max(0, pd.brakeThrottle - cfg.BRAKE_RELEASE_RATE)
		else
			if pd.fuelRange > 0 then
				pd.throttle = math.min(1, pd.throttle + cfg.THROTTLE_INCREASE_RATE)
			end
		end
		pd.isBraking = false
	elseif input.throttleDown then
		if pd.throttle > 0 then
			pd.throttle = math.max(0, pd.throttle - cfg.THROTTLE_INCREASE_RATE)
		else
			pd.brakeThrottle = math.min(1, pd.brakeThrottle + cfg.BRAKE_INCREASE_RATE)
		end
		pd.isBraking = true
	else
		pd.throttle = math.max(0, pd.throttle - cfg.THROTTLE_DECAY_RATE)
		pd.brakeThrottle = math.max(0, pd.brakeThrottle - cfg.BRAKE_RELEASE_RATE)
		pd.isBraking = false
	end

	-- Local engine/wind sounds
	if pd.engineSound then
		local t = pd.throttle
		pd.engineSound.Volume = cfg.ENGINE_MIN_VOLUME + (cfg.ENGINE_MAX_VOLUME - cfg.ENGINE_MIN_VOLUME) * t
		pd.engineSound.Pitch  = cfg.ENGINE_MIN_PITCH  + (cfg.ENGINE_MAX_PITCH  - cfg.ENGINE_MIN_PITCH ) * t
	end
	if pd.windSound then
		local sPct = math.clamp((pd.realSpeed - cfg.WIND_START_SPEED) / (pd.maxSpeed - cfg.WIND_START_SPEED), 0, 1)
		pd.windSound.Volume = cfg.WIND_MIN_VOLUME + (cfg.WIND_MAX_VOLUME - cfg.WIND_MIN_VOLUME) * sPct
		pd.windSound.Pitch  = cfg.WIND_MIN_PITCH  + (cfg.WIND_MAX_PITCH  - cfg.WIND_MIN_PITCH ) * sPct
	end

	-- Gear toggle
	if input.landing then
		pd.gear = not pd.gear
		gearToggleRemote:FireServer(pd.plane)
		input.landing = false
	end

	-- Health throttle multiplier
	pd.throttle = pd.throttle * (pd.plane:GetAttribute("ThrottleMultiplier") or 1.0)

	-- Speed model
	local vary = -pd.main.CFrame.LookVector.Y * (pd.speedVary or 0)
	local vmax = math.max(1, (pd.maxSpeed or 200) + vary)
	local forward = vmax * pd.throttle
	local brake   = vmax * pd.brakeThrottle * cfg.BRAKE_FORCE_MULTIPLIER
	pd.desiredSpeed = forward + brake

	local change = (pd.desiredSpeed > pd.currentSpeed) and 1 or -1
	local ns = pd.currentSpeed + (pd.accel or 1) * change
	if change == 1 then
		pd.currentSpeed = math.min(ns, pd.desiredSpeed)
	else
		pd.currentSpeed = math.max(ns, math.max(pd.desiredSpeed, -20))
	end

	local stl = stall(pd)
	if pd.lastStall and not stl and not isTaxiing(pd) then
		if not pd.isBraking and pd.realSpeed > 10 and pd.realSpeed < pd.maxSpeed then
			local sd = pd.realSpeed - pd.currentSpeed
			pd.currentSpeed = pd.currentSpeed + (sd * 0.1)
		end
	end
	pd.lastStall = stl

	local onGround = Workspace:FindPartOnRay(Ray.new(pd.main.Position, Vector3.new(0, -pd.lowestPoint, 0)), pd.plane)
	if not onGround and pd.realSpeed > cfg.LANDING_MIN_AIR_SPEED then
		pd.hasBeenAirborne = true
	end
	if onGround and pd.hasBeenAirborne and pd.realSpeed > cfg.LANDING_DETECTION_SPEED and pd.landingTime == 0 then
		pd.landingTime = tick()
		pd.hasBeenAirborne = false
		local cap = cfg.MAX_SAFE_FORCE * 0.3
		pd.move.MaxForce = Vector3.new(cap, cap, cap)
	end

	local inGrace = false
	if pd.landingTime > 0 then
		if (tick() - pd.landingTime) < cfg.LANDING_GRACE_TIME then
			inGrace = true
		else
			pd.landingTime = 0
		end
	end

	local baseVelocity = pd.main.CFrame.LookVector * pd.currentSpeed

	-- Stall downward clamp
	if stl and not onGround then
		if baseVelocity.Y < -80 then
			baseVelocity = Vector3.new(baseVelocity.X, -80, baseVelocity.Z)
		end
	end

	-- Orientation authority
	local rawBank = (((input.viewSizeX/2) - input.mouseX) / math.max(1, (input.viewSizeX/2))) * pd.maxBank
	local bank = math.clamp(rawBank, -pd.maxBank, pd.maxBank)
	local groundCFrame = CFrame.new(pd.main.Position, input.mouseHitP)
	local flightCFrame = input.mouseHit * CFrame.Angles(0, 0, math.rad(bank))
	local targetCFrame = groundCFrame:Lerp(flightCFrame, transitionFactor)

	-- v4.2 Recovery assist
	local targetLookY = targetCFrame.LookVector.Y
	local noseUpIntent = math.clamp((-targetLookY - 0.02) / 0.6, 0, 1)
	local throttleIntent = math.clamp((pd.throttle - 0.5) / 0.5, 0, 1)
	local speedOK = (pd.currentSpeed >= (pd.cfg.STALL_SPEED * 0.85)) and 1 or 0
	local recoveryIntent = math.clamp(0.65 * noseUpIntent + 0.35 * throttleIntent, 0, 1) * speedOK

	local riseTau, decayTau = 0.20, 0.45
	local k = dt / ((recoveryIntent > pd.fallAssist) and riseTau or decayTau)
	k = math.clamp(k, 0, 1)
	pd.fallAssist = pd.fallAssist + (recoveryIntent - pd.fallAssist) * k

	-- Fall terms
	local fallSpeed = (1 - transitionFactor) * cfg.MAX_FALL_SPEED
	local effectiveFall = fallSpeed * (1 - 0.9 * pd.fallAssist)

	local totalDown = baseVelocity.Y - effectiveFall
	if totalDown < -150 then
		effectiveFall = effectiveFall * 0.5
	end

	-- Hard clamp forward magnitude before fall
	if baseVelocity.Magnitude > cfg.MAX_VELOCITY then
		baseVelocity = baseVelocity.Unit * cfg.MAX_VELOCITY
	end

	-- Gyro force setup
	local F = cfg.MAX_SAFE_FORCE
	local pitchSensitivity = cfg.PITCH_SENSITIVITY or 1.0
	local bankSensitivity  = cfg.BANK_SENSITIVITY  or 1.0
	local targetPitchTorque = F * transitionFactor * pitchSensitivity
	local targetBankTorque  = F * bankSensitivity

	local TERMINAL_FALL_SPEED = cfg.TERMINAL_FALL_SPEED or 160

	if onGround then
		pd.move.Velocity = baseVelocity
		if pd.currentSpeed < 2 then
			pd.move.MaxForce = Vector3.new(0,0,0)
			pd.gyro.MaxTorque = Vector3.new(0,0,0)
			pd.gyro.CFrame = groundCFrame
		elseif inGrace then
			pd.move.MaxForce = Vector3.new(F*0.1, F*0.05, F*0.1)
			pd.gyro.MaxTorque = Vector3.new(0, F*0.1, 0)
			pd.gyro.CFrame = groundCFrame
		else
			local forceMult = stl and 0.3 or 1.0
			local yAxisForce = F * transitionFactor * forceMult
			yAxisForce = yAxisForce * (1 + 0.25 * pd.fallAssist)
			pd.move.MaxForce = Vector3.new(F, yAxisForce, F)
			pd.gyro.MaxTorque = Vector3.new(targetPitchTorque, F, targetBankTorque)
			pd.gyro.CFrame = targetCFrame
		end
	else
		local vy = baseVelocity.Y - effectiveFall
		if vy < -TERMINAL_FALL_SPEED then
			vy = -TERMINAL_FALL_SPEED
		end
		pd.move.Velocity = Vector3.new(baseVelocity.X, vy, baseVelocity.Z)

		local forceMult = stl and 0.3 or 1.0
		local yAxisForce = F * transitionFactor * forceMult
		yAxisForce = yAxisForce * (1 + 0.35 * pd.fallAssist)

		pd.move.MaxForce = Vector3.new(F * forceMult, yAxisForce, F * forceMult)
		pd.gyro.MaxTorque = Vector3.new(targetPitchTorque, F, targetBankTorque)
		pd.gyro.CFrame = targetCFrame

		local v = pd.main.AssemblyLinearVelocity
		if v.Y < -TERMINAL_FALL_SPEED then
			pd.main.AssemblyLinearVelocity = Vector3.new(v.X, -TERMINAL_FALL_SPEED, v.Z)
		end
	end

	-- Hard overall velocity clamp
	local vel = pd.main.AssemblyLinearVelocity
	if vel.Magnitude > cfg.MAX_VELOCITY then
		pd.main.AssemblyLinearVelocity = vel.Unit * (cfg.MAX_VELOCITY * 0.8)
	end
end

-- ===== GUI Animation =====
RunService.Heartbeat:Connect(function()
	currentThrottle = currentThrottle + (targetThrottle - currentThrottle) * 0.15
	currentBrake    = currentBrake    + (targetBrake    - currentBrake)    * 0.15
	currentRange    = currentRange    + (targetRange    - currentRange)    * 0.05

	local throttleHeight = math.clamp(currentThrottle, 0, 1) * 300
	throttleBar.Size = UDim2.new(0, 26, 0, throttleHeight)

	if targetBrake > 0.01 or currentBrake > 0.01 then
		brakeBar.Visible = true
		local brakeHeight = math.clamp(currentBrake, 0, 1) * 300
		brakeBar.Size = UDim2.new(0, 26, 0, brakeHeight)
		brakeBar.BackgroundTransparency = 0.3
	else
		brakeBar.Visible = false
	end

	local rangeHeight = math.clamp(currentRange, 0, 1) * 300
	rangeBar.Size = UDim2.new(0, 26, 0, rangeHeight)
	if currentRange > 0.5 then
		rangeBar.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
	elseif currentRange > 0.25 then
		local blend = (currentRange - 0.25) / 0.25
		rangeBar.BackgroundColor3 = Color3.fromRGB(255, 255, math.floor(100 * blend))
	else
		rangeBar.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
	end

	if currentThrottle > 0.95 then
		local pulse = math.sin(tick()*3)*0.2 + 0.3
		throttleBar.BackgroundTransparency = pulse
	else
		throttleBar.BackgroundTransparency = 0.3
	end

	if currentRange < 0.1 then
		local pulse = math.sin(tick()*5)*0.3 + 0.3
		rangeBar.BackgroundTransparency = pulse
	else
		rangeBar.BackgroundTransparency = 0.3
	end

	if gpHaveRecentLook then
		gpRightX = gpRightX * gpLookDecay
		gpRightY = gpRightY * gpLookDecay
		if math.abs(gpRightX) < 0.02 and math.abs(gpRightY) < 0.02 then
			gpHaveRecentLook = false
		end
	end
	if haveRecentTouchLook and (touchLookVec.Magnitude < 0.02) then
		haveRecentTouchLook = false
	end
end)

throttleRemote.OnClientEvent:Connect(function(throttle, brake, range)
	targetThrottle = throttle or 0
	targetBrake    = brake or 0
	targetRange    = range or 1
end)

-- ===== Seat monitoring (Simplified — NO camera manipulation) =====
local function onSeatChanged(active, seat)
	if active and seat then
		local isPlane = seat:FindFirstChild("IsPlane")
		if not isPlane then return end
		local plane = seat.Parent and seat.Parent.Parent
		if not (plane and plane:FindFirstChild("MainParts")) then return end

		currentSeat = seat
		currentPlane = plane
		flying = true
		activateRemote:FireServer(plane, true)

		-- Build local pd
		pcall(function()
			local mainParts = currentPlane:FindFirstChild("MainParts")
			local main = mainParts:FindFirstChild("Main")
			local landing = mainParts:FindFirstChild("LandingGear")
			local cfg = require(currentPlane:FindFirstChild("PlaneConfig"))

			local move = main:WaitForChild("Move", 5)
			local gyro = main:WaitForChild("Gyro", 5)
			if not (move and gyro) then
				warn("❌ Failed to find Move/Gyro objects!")
				return
			end

			local gearParts = {}
			if landing then gearParts = setupGearParts(landing) end
			local lowestPoint = getLowestPoint(main, gearParts)

			local engineSound = mkSound(main, "EngineSound", cfg.ENGINE_SOUND_ID, cfg.ENGINE_MIN_VOLUME, cfg.ENGINE_MIN_PITCH, cfg.ENGINE_SOUND_ROLLOFF)
			local windSound   = mkSound(main, "WindSound",   cfg.WIND_SOUND_ID,   0,                    cfg.WIND_MIN_PITCH,   cfg.WIND_SOUND_ROLLOFF)

			currentPlaneData = {
				plane = currentPlane, cfg = cfg, main = main, seat = currentSeat, landingGear = landing,
				move = move, gyro = gyro,
				gearParts = gearParts,
				lowestPoint = lowestPoint,

				accel = cfg.ACCELERATION,
				maxBank = math.clamp(cfg.MAX_BANK, -90, 90),
				maxSpeed = cfg.MAX_SPEED,
				speedVary = cfg.SPEED_DIFFERENTIAL,
				stallSpeed = math.min(cfg.STALL_SPEED, cfg.MAX_SPEED),

				desiredSpeed = 0, currentSpeed = 0, realSpeed = 0,

				throttle = 0, brakeThrottle = 0,
				fuelRange = currentPlane:GetAttribute("FuelRange") or 1.0,

				on = true, dead = false, gear = true,

				lastPos = main.Position, lastTime = tick(), lastStall = false,
				isBraking = false, landingTime = 0, hasBeenAirborne = false,

				engineSound = engineSound,
				windSound = windSound,

				player = player,

				fallAssist = 0,
			}

			if currentPlaneData.engineSound then currentPlaneData.engineSound:Play() end
			if currentPlaneData.windSound then   currentPlaneData.windSound:Play()   end
		end)

		-- Force default camera mode explicitly (optional but harmless)
		workspace.CurrentCamera.CameraType = Enum.CameraType.Custom

		gui.Enabled = true
		rangeBar.BackgroundTransparency = 1
		throttleBar.BackgroundTransparency = 1
		brakeBar.BackgroundTransparency = 1
		brakeBar.Visible = false

		TweenService:Create(rangeBar,    TweenInfo.new(0.5, Enum.EasingStyle.Quad), {BackgroundTransparency = 0.3}):Play()
		TweenService:Create(throttleBar, TweenInfo.new(0.5, Enum.EasingStyle.Quad), {BackgroundTransparency = 0.3}):Play()

		mobileHud.Enabled = isMobile

	else
		if flying then
			flying = false

			-- Clean up local sounds/state
			if currentPlaneData then
				if currentPlaneData.engineSound then currentPlaneData.engineSound:Destroy() end
				if currentPlaneData.windSound   then currentPlaneData.windSound:Destroy()   end
				currentPlaneData = nil
			end

			if currentPlane then
				activateRemote:FireServer(currentPlane, false)
			end
			currentSeat, currentPlane = nil, nil

			TweenService:Create(rangeBar,    TweenInfo.new(0.5, Enum.EasingStyle.Quad), {BackgroundTransparency = 1}):Play()
			TweenService:Create(throttleBar, TweenInfo.new(0.5, Enum.EasingStyle.Quad), {BackgroundTransparency = 1}):Play()
			if brakeBar.Visible then
				TweenService:Create(brakeBar, TweenInfo.new(0.5, Enum.EasingStyle.Quad), {BackgroundTransparency = 1}):Play()
			end
			task.delay(0.55, function()
				gui.Enabled = false
				mobileHud.Enabled = false
				currentThrottle, currentBrake, targetThrottle, targetBrake = 0,0,0,0
				currentRange, targetRange = 1,1
				brakeBar.Visible = false
			end)
		end
	end
end

player.CharacterAdded:Connect(function(character)
	local humanoid = character:WaitForChild("Humanoid")
	humanoid.Seated:Connect(onSeatChanged)
end)
if player.Character then
	local humanoid = player.Character:FindFirstChild("Humanoid")
	if humanoid then humanoid.Seated:Connect(onSeatChanged) end
end

-- ===== CONTINUOUS PHYSICS LOOP (Heartbeat-timed) =====
local lastPhysicsUpdate = tick()
task.spawn(function()
	while true do
		RunService.Heartbeat:Wait()
		local now = tick()
		local dt = now - lastPhysicsUpdate
		lastPhysicsUpdate = now

		if flying and currentPlane and currentPlaneData then
			local mx, my, vx, vy, mHit, mHitP = getAim()
			local input = {
				mouseX = mx, mouseY = my,
				viewSizeX = vx, viewSizeY = vy,
				mouseHit = mHit, mouseHitP = mHitP,
				throttleUp = keys.spdup.down,
				throttleDown = keys.spddwn.down,
				landing = keys.landing.down
			}
			pcall(update, currentPlaneData, input, dt)

			-- lightweight throttle sync (every ~0.1s)
			if tick() % 0.1 < dt then
				throttleSyncRemote:FireServer(currentPlane, currentPlaneData.throttle)
			end

			if keys.landing.down then keys.landing.down = false end
		end
	end
end)

-- ===== DESKTOP KEYBOARD =====
mouse.KeyDown:Connect(function(k)
	if not flying then return end
	k = k:lower()
	if k == "g" then
		keys.landing.down = true
	elseif k == "w" or k:byte() == 17 then
		keys.spdup.down = true
	elseif k == "s" or k:byte() == 18 then
		keys.spddwn.down = true
	end
end)
mouse.KeyUp:Connect(function(k)
	k = k:lower()
	if k == "g" then
		keys.landing.down = false
	elseif k == "w" or k:byte() == 17 then
		keys.spdup.down = false
	elseif k == "s" or k:byte() == 18 then
		keys.spddwn.down = false
	end
end)

-- ===== MOBILE BUTTONS =====
local function bindMobileButtons()
	throttleUpBtn.MouseButton1Down:Connect(function()
		if flying then keys.spdup.down = true end
	end)
	throttleUpBtn.MouseButton1Up:Connect(function()
		keys.spdup.down = false
	end)
	throttleUpBtn.TouchLongPress:Connect(function(_,state)
		if state == Enum.UserInputState.Begin then keys.spdup.down = true end
		if state == Enum.UserInputState.End   then keys.spdup.down = false end
	end)

	throttleDownBtn.MouseButton1Down:Connect(function()
		if flying then keys.spddwn.down = true end
	end)
	throttleDownBtn.MouseButton1Up:Connect(function()
		keys.spddwn.down = false
	end)
	throttleDownBtn.TouchLongPress:Connect(function(_,state)
		if state == Enum.UserInputState.Begin then keys.spddwn.down = true end
		if state == Enum.UserInputState.End   then keys.spddwn.down = false end
	end)

	gearBtn.MouseButton1Click:Connect(function()
		if flying then
			keys.landing.down = true
		end
	end)
end
bindMobileButtons()

-- ===== MOBILE / CONSOLE LOOK (right-side drag / thumbstick) =====
UserInputService.TouchStarted:Connect(function(touch, gp)
	if not flying then return end
	local vp = workspace.CurrentCamera.ViewportSize
	if touch.Position.X > vp.X * 0.55 then
		-- NOTE: this uses UserInputState as the "id" (simple heuristic kept from your version)
		touchLookId = touch.UserInputState
		touchLookVec = Vector2.new()
		haveRecentTouchLook = true
	end
end)
UserInputService.TouchMoved:Connect(function(touch, gp)
	if not flying then return end
	if touchLookId and touch.UserInputState == touchLookId then
		local delta = touch.Delta
		touchLookVec = touchLookVec + Vector2.new(delta.X, delta.Y) * 0.002
		touchLookVec = Vector2.new(math.clamp(touchLookVec.X, -1, 1), math.clamp(touchLookVec.Y, -1, 1))
		haveRecentTouchLook = true
	end
end)
UserInputService.TouchEnded:Connect(function(touch, gp)
	if touchLookId and touch.UserInputState == touchLookId then
		touchLookId = nil
	end
end)

-- Gamepad throttle + look
local function gamepadActionThrottleUp(actionName, inputState, inputObj)
	if not flying then return Enum.ContextActionResult.Pass end
	if inputState == Enum.UserInputState.Begin then keys.spdup.down = true
	elseif inputState == Enum.UserInputState.End then keys.spdup.down = false end
	return Enum.ContextActionResult.Sink
end
local function gamepadActionThrottleDown(actionName, inputState, inputObj)
	if not flying then return Enum.ContextActionResult.Pass end
	if inputState == Enum.UserInputState.Begin then keys.spddwn.down = true
	elseif inputState == Enum.UserInputState.End then keys.spddwn.down = false end
	return Enum.ContextActionResult.Sink
end
local function gamepadActionGear(actionName, inputState, inputObj)
	if not flying then return Enum.ContextActionResult.Pass end
	if inputState == Enum.UserInputState.Begin then
		keys.landing.down = true
	elseif inputState == Enum.UserInputState.End then
		keys.landing.down = false
	end
	return Enum.ContextActionResult.Sink
end

ContextActionService:BindAction("Plane_ThrottleUp",   gamepadActionThrottleUp,   false, Enum.KeyCode.ButtonR2)
ContextActionService:BindAction("Plane_ThrottleDown", gamepadActionThrottleDown, false, Enum.KeyCode.ButtonL2)
ContextActionService:BindAction("Plane_Gear",         gamepadActionGear,         false, Enum.KeyCode.ButtonY)

UserInputService.InputChanged:Connect(function(input, gp)
	if not flying then return end
	if input.UserInputType == Enum.UserInputType.Gamepad1 and input.KeyCode == Enum.KeyCode.Thumbstick2 then
		local v = input.Position
		gpRightX = v.X
		gpRightY = v.Y
		if math.abs(gpRightX) > 0.05 or math.abs(gpRightY) > 0.05 then
			gpHaveRecentLook = true
		end
	end
end)

print("✅ CLIENT PLANE INPUT: Loaded (v4.2-min — default camera, no custom camera code)")
