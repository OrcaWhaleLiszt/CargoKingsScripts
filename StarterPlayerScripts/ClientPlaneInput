-- ClientPlaneInput.lua (v4.0 - Reverted to original - Integrated smooth camera with desktop pan/zoom)
-- Put this LocalScript in: StarterPlayer > StarterPlayerScripts
--
-- MODIFIED: This script now runs the FULL physics 'update' loop locally
-- on RenderStepped to eliminate server-client physics jitter.

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local GuiService = game:GetService("GuiService")
local Workspace = game:GetService("Workspace") -- Added Workspace reference

-- ===== CAMERA CONFIG =====
local CAMERA_DISTANCE = 40        -- Base distance behind plane
local CAMERA_HEIGHT = 8           -- Height above plane
local CAMERA_SMOOTHING = 0.25     -- Camera lag (INCREASED from 0.15 for smoother following)
local MAX_ZOOM = 60           -- Farthest zoom out
local MIN_ZOOM = 15           -- Closest zoom in
local ZOOM_SPEED = 3          -- Mouse wheel zoom speed
local ORBIT_SENSITIVITY = 0.3     -- Right-click orbit speed
-- =========================

local player = Players.LocalPlayer
local mouse = player:GetMouse()
local playerGui = player:WaitForChild("PlayerGui")
local camera = workspace.CurrentCamera -- Using workspace global is generally okay here

-- Detect device type
local isMobile = UserInputService.TouchEnabled and not UserInputService.MouseEnabled
local isDesktop = not isMobile and UserInputService.MouseEnabled

-- ===== Remotes =====
local remoteFolder = ReplicatedStorage:WaitForChild("PlaneRemotes", 10)
if not remoteFolder then warn("❌ PlaneRemotes folder not found!"); return end

local inputRemote    = remoteFolder:WaitForChild("PlaneInput", 5) -- Unused by v4.2, kept for compatibility
local activateRemote = remoteFolder:WaitForChild("PlaneActivate", 5)
local throttleRemote = remoteFolder:WaitForChild("ThrottleUpdate", 5)
-- NEW REMOTES
local gearToggleRemote = remoteFolder:WaitForChild("RE_GearToggle", 5)
local throttleSyncRemote = remoteFolder:WaitForChild("RE_ThrottleSync", 5)
local crashRemote = remoteFolder:WaitForChild("PlaneCrash", 5)

if not (inputRemote and activateRemote and throttleRemote and gearToggleRemote and throttleSyncRemote and crashRemote) then
	warn("❌ Failed to find all plane remotes!")
	return
end

-- ===== GUI: throttle/fuel bars (Existing GUI setup) =====
local gui = Instance.new("ScreenGui")
gui.Name = "PlaneIndicators"
gui.ResetOnSpawn = false
gui.Enabled = false
gui.Parent = playerGui

local rangeBar = Instance.new("Frame")
rangeBar.Size = UDim2.new(0, 26, 0, 300)
rangeBar.Position = UDim2.new(0, 20, 1, -20)
rangeBar.AnchorPoint = Vector2.new(0, 1)
rangeBar.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
rangeBar.BackgroundTransparency = 0.3
rangeBar.BorderSizePixel = 0
rangeBar.Parent = gui
Instance.new("UICorner", rangeBar).CornerRadius = UDim.new(0,8)

local throttleBar = Instance.new("Frame")
throttleBar.Size = UDim2.new(0, 26, 0, 0)
throttleBar.Position = UDim2.new(0, 56, 1, -20)
throttleBar.AnchorPoint = Vector2.new(0, 1)
throttleBar.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
throttleBar.BackgroundTransparency = 0.3
throttleBar.BorderSizePixel = 0
throttleBar.Parent = gui
Instance.new("UICorner", throttleBar).CornerRadius = UDim.new(0,8)

local brakeBar = Instance.new("Frame")
brakeBar.Size = UDim2.new(0, 26, 0, 0)
brakeBar.Position = UDim2.new(0, 56, 1, -20)
brakeBar.AnchorPoint = Vector2.new(0, 1)
brakeBar.BackgroundColor3 = Color3.fromRGB(255, 60, 60)
brakeBar.BackgroundTransparency = 0.3
brakeBar.Visible = false
brakeBar.Parent = gui
Instance.new("UICorner", brakeBar).CornerRadius = UDim.new(0,8)

-- ===== Mobile HUD (Existing Mobile HUD setup) =====
local mobileHud = Instance.new("ScreenGui")
mobileHud.Name = "PlaneMobileHUD"
mobileHud.ResetOnSpawn = false
mobileHud.Enabled = false
mobileHud.Parent = playerGui

local function mkButton(name, anchor, pos, size, text)
	local b = Instance.new("TextButton")
	b.Name = name
	b.AnchorPoint = anchor
	b.Position = pos
	b.Size = size
	b.Text = text
	b.TextScaled = true
	b.BackgroundTransparency = 0.2
	b.BackgroundColor3 = Color3.fromRGB(30,30,30)
	b.TextColor3 = Color3.new(1,1,1)
	b.AutoButtonColor = true
	b.Parent = mobileHud
	local corner = Instance.new("UICorner", b)
	corner.CornerRadius = UDim.new(0,12)
	return b
end

local throttleUpBtn   = mkButton("ThrottleUp",   Vector2.new(0,1), UDim2.new(0,20, 1,-90), UDim2.new(0,80, 0,80), "▲")
local throttleDownBtn = mkButton("ThrottleDown", Vector2.new(0,1), UDim2.new(0,20, 1,-5),  UDim2.new(0,80, 0,80), "▼")
local gearBtn = mkButton("Gear", Vector2.new(1,0), UDim2.new(1,-20, 0, 20), UDim2.new(0,120, 0,60), "Gear")

-- ===== State =====
local currentSeat, currentPlane
local currentPlaneData = nil -- NEW: Will hold the client-side 'pd' table
local flying = false
local keys = {
	landing = {key = "g", down = false},
	spdup   = {down = false},
	spddwn  = {down = false}
}
local currentThrottle, currentBrake, targetThrottle, targetBrake = 0,0,0,0
local currentRange, targetRange = 1,1

-- Camera state (New variables for custom camera)
local currentZoom = CAMERA_DISTANCE
local isOrbiting = false
local orbitX, orbitY = 0, 0
local lastMouseX, lastMouseY = 0, 0
local currentCameraPosition = nil  -- Track actual camera position
local currentCameraLookAt = nil    -- Track where camera is looking
local cameraConnection = nil       -- Connection for RenderStepped

-- Gamepad look state (Existing)
local gpRightX, gpRightY = 0, 0
local gpHaveRecentLook = false
local gpLookDecay = 0.9

-- Touch look state (Original v4.0 - used for aiming on mobile/console)
local touchLookId = nil
local touchLookVec = Vector2.new()
local haveRecentTouchLook = false

-- ========================================================
-- [NEW] HELPER FUNCTIONS (COPIED FROM SERVER SCRIPT)
-- ========================================================

-- (Copied from server initPlane)
local function mkSound(main, name, id, minVol, minPitch, rolloff)
	if not id then return nil end
	local s = Instance.new("Sound")
	s.Name = name
	s.SoundId = id
	s.RollOffMode = Enum.RollOffMode.Linear
	s.RollOffMaxDistance = rolloff or 200
	s.Looped = true
	s.Volume = minVol or 0
	s.Pitch = minPitch or 1
	s.Parent = main
	return s
end

-- (Copied from server initPlane)
local function setupGearParts(landingGearInstance)
	local gearParts = {}
	local function getGear(p)
		for _,v in ipairs(p:GetChildren()) do
			if v:IsA("BasePart") then
				if not v:FindFirstChild("Trans") then
					local t = Instance.new("NumberValue", v); t.Name="Trans"; t.Value=v.Transparency
					local r = Instance.new("NumberValue", v); r.Name="Ref"; r.Value=v.Reflectance
					local c = Instance.new("BoolValue", v); c.Name="Collide"; c.Value=v.CanCollide
				end
				table.insert(gearParts, v)
			end
			getGear(v)
		end
	end
	getGear(landingGearInstance)
	return gearParts
end

-- (Copied from server initPlane)
local function getLowestPoint(main, gearParts)
	local lowestPoint = 0
	if #gearParts == 0 then
		lowestPoint = (main.Position.Y + 5 + (main.Size.Y/2))
	else
		for _,v in ipairs(gearParts) do
			local _0 = (main.Position.Y-(v.CFrame*CFrame.new((v.Size.X/2),0,0)).Y)
			local _1 = (main.Position.Y-(v.CFrame*CFrame.new(-(v.Size.X/2),0,0)).Y)
			local _2 = (main.Position.Y-(v.CFrame*CFrame.new(0,(v.Size.Y/2),0)).Y)
			local _3 = (main.Position.Y-(v.CFrame*CFrame.new(0,-(v.Size.Y/2),0)).Y)
			local _4 = (main.Position.Y-(v.CFrame*CFrame.new(0,0,(v.Size.Z/2))).Y)
			local _5 = (main.Position.Y-(v.CFrame*CFrame.new(0,0,-(v.Size.Z/2))).Y)
			local n = (math.max(_0,_1,_2,_3,_4,_5)+5)
			if n > lowestPoint then lowestPoint = n end
		end
	end
	return lowestPoint
end

-- (Copied from server helpers)
local function calculateTransition(speed, transStart, transEnd)
	if speed <= transStart then return 0 end
	if speed >= transEnd then return 1 end
	if (transEnd - transStart) == 0 then return 1 end
	return (speed - transStart) / (transEnd - transStart)
end

-- (Copied from server helpers)
-- Note: 'pd' is the client-side 'currentPlaneData' table
local function isTaxiing(pd)
	local onGround = Workspace:FindPartOnRay(Ray.new(pd.main.Position, Vector3.new(0, -pd.lowestPoint, 0)), pd.plane)
	return onGround and pd.currentSpeed <= pd.cfg.STALL_SPEED
end

-- (Copied from server helpers)
-- Note: 'pd' is the client-side 'currentPlaneData' table
local function stall(pd)
	if pd.isBraking and pd.desiredSpeed < pd.cfg.STALL_SPEED then return false end
	local diff = ((pd.realSpeed - pd.cfg.STALL_SPEED) / 200)
	diff = (diff > 0.9 and 0.9 or diff)
	local check = {
		(pd.currentSpeed <= pd.cfg.STALL_SPEED),
		(pd.main.CFrame.lookVector.Y > (pd.realSpeed < pd.cfg.STALL_SPEED and -1 or diff))
	}
	for _, c in ipairs(check) do if not c then return false end end
	return true
end
-- ========================================================
-- [END] HELPER FUNCTIONS
-- ========================================================


-- ===== Helpers: Aim for mobile/console (Original v4.0) =====
local function getAim()
	-- On desktop, the aim is always the mouse position regardless of custom camera
	if isDesktop then
		return mouse.X, mouse.Y, mouse.ViewSizeX, mouse.ViewSizeY, mouse.Hit, mouse.Hit.p
	end

	-- On mobile/console, aim is derived from touch/thumbstick input
	local cam = workspace.CurrentCamera
	local origin = cam.CFrame.Position
	local dir

	local vx, vy = 0, 0
	if haveRecentTouchLook then
		vx, vy = touchLookVec.X, touchLookVec.Y
	elseif gpHaveRecentLook then
		vx, vy = gpRightX, gpRightY
	end

	local lookCF = cam.CFrame
	local yaw   = vx * 0.7
	local pitch = -vy * 0.5
	local aimCF = lookCF * CFrame.Angles(0, yaw, 0) * CFrame.Angles(pitch, 0, 0)
	dir = aimCF.LookVector * 500

	-- Uses DEPRECATED FindPartOnRay - Replace if needed
	local ray = Ray.new(origin, dir)
	local hitPart, hitPos = workspace:FindPartOnRay(ray, player.Character, false, true)
	local fallbackPos = origin + dir
	local hitCFrame = CFrame.new(fallbackPos)
	if hitPart then
		hitCFrame = CFrame.new(hitPos)
	end

	local vp = cam.ViewportSize
	local cx, cy = math.floor(vp.X/2), math.floor(vp.Y/2)
	return cx, cy, vp.X, vp.Y, hitCFrame, hitCFrame.Position
end


-- ========================================================
-- [NEW] LOCAL PHYSICS UPDATE (COPIED FROM SERVER)
-- ========================================================
-- This function is the *entire* v4.2 physics simulation,
-- copied from the server script. It now runs locally.
-- It expects the client-side 'pd' table and 'input' table.

-- [CRASH DETECTION STATE]
local crashDetectionState = {
	wasHighSpeed = false,
	suddenDropTime = 0,
	crashPending = false
}

local function update(pd, input, dt) -- Added 'dt' as parameter
	if not pd.on or not pd.player then return end
	if not (input and input.viewSizeX and input.mouseX and input.mouseHit and input.mouseHitP) then return end

	local cfg = pd.cfg

	-- Direct delta time and speed calculation
	-- local now = tick() -- We now get 'dt' from RenderStepped
	-- local dt = now - pd.lastTime
	if dt <= 0 then return end

	local dist = (pd.lastPos - pd.main.Position).Magnitude
	pd.realSpeed = (dist / dt) -- direct, no smoothing

	pd.lastPos = pd.main.Position
	-- pd.lastTime = now -- No longer needed

	-- ===== [NEW] CRASH DETECTION =====
	local crashThreshold = cfg.CRASH_SPEED_THRESHOLD or 150
	local now = tick()

	-- Check if we were going fast
	if pd.realSpeed >= crashThreshold then
		crashDetectionState.wasHighSpeed = true
		crashDetectionState.suddenDropTime = 0
		crashDetectionState.crashPending = false
	end

	-- Check for sudden speed drop (from high speed to 10% or less)
	if crashDetectionState.wasHighSpeed and pd.realSpeed <= (crashThreshold * 0.1) then
		if crashDetectionState.suddenDropTime == 0 then
			-- First detection of sudden drop
			crashDetectionState.suddenDropTime = now
			crashDetectionState.crashPending = true
		elseif crashDetectionState.crashPending and (now - crashDetectionState.suddenDropTime) >= 0.5 then
			-- Half second has passed, still at low speed = CRASH!
			print("💥 CRASH DETECTED! Speed dropped from " .. crashThreshold .. " to " .. pd.realSpeed)

			-- Tell server about the crash
			if crashRemote then
				print("🔥 Firing crash remote to server...")
				crashRemote:FireServer(pd.plane)
			else
				warn("❌ Crash remote not found!")
			end

			-- Reset crash detection
			crashDetectionState.wasHighSpeed = false
			crashDetectionState.suddenDropTime = 0
			crashDetectionState.crashPending = false

			-- Stop physics immediately
			pd.on = false
			return
		end
	elseif pd.realSpeed > (crashThreshold * 0.1) then
		-- Speed recovered, cancel crash detection
		if crashDetectionState.crashPending then
			crashDetectionState.crashPending = false
			crashDetectionState.suddenDropTime = 0
		end
	end
	-- ===== [END CRASH DETECTION] =====

	-- SAFETY: Void prevention
	if pd.main.Position.Y < cfg.VOID_THRESHOLD then
		pd.main.CFrame = CFrame.new(pd.main.Position.X, 50, pd.main.Position.Z)
		pd.main.AssemblyLinearVelocity = Vector3.new(0, -10, 0)
		print("⚠️ VOID PREVENTION - Teleported to safety!")
	end

	-- Transition factor
	local transitionFactor = calculateTransition(pd.currentSpeed, cfg.TRANSITION_START, cfg.TRANSITION_END)

	-- Fuel
	-- [REMOVED] Server now handles fuel drain.
	-- The server will send 'targetRange' to the throttleRemote listener.
	pd.fuelRange = targetRange -- Sync local pd value from GUI target

	-- Throttle/brake
	if input.throttleUp then
		if pd.brakeThrottle > 0 then
			pd.brakeThrottle = math.max(0, pd.brakeThrottle - cfg.BRAKE_RELEASE_RATE)
		else
			if pd.fuelRange > 0 then -- Check local fuelRange
				pd.throttle = math.min(1, pd.throttle + cfg.THROTTLE_INCREASE_RATE)
			end
		end
		pd.isBraking = false
	elseif input.throttleDown then
		if pd.throttle > 0 then
			pd.throttle = math.max(0, pd.throttle - cfg.THROTTLE_INCREASE_RATE)
		else
			pd.brakeThrottle = math.min(1, pd.brakeThrottle + cfg.BRAKE_INCREASE_RATE)
		end
		pd.isBraking = true
	else
		pd.throttle = math.max(0, pd.throttle - cfg.THROTTLE_DECAY_RATE)
		pd.brakeThrottle = math.max(0, pd.brakeThrottle - cfg.BRAKE_RELEASE_RATE)
		pd.isBraking = false
	end

	-- Force throttle to 0 if no fuel
	if pd.fuelRange <= 0 then
		pd.throttle = 0
	end

	-- Sounds (Now controls local sounds)
	if pd.engineSound then
		local t = pd.throttle
		pd.engineSound.Volume = cfg.ENGINE_MIN_VOLUME + (cfg.ENGINE_MAX_VOLUME - cfg.ENGINE_MIN_VOLUME) * t
		pd.engineSound.Pitch = cfg.ENGINE_MIN_PITCH + (cfg.ENGINE_MAX_PITCH - cfg.ENGINE_MIN_PITCH ) * t
	end
	if pd.windSound then
		local sPct = math.clamp((pd.realSpeed - cfg.WIND_START_SPEED) / (pd.maxSpeed - cfg.WIND_START_SPEED), 0, 1)
		pd.windSound.Volume = cfg.WIND_MIN_VOLUME + (cfg.WIND_MAX_VOLUME - cfg.WIND_MIN_VOLUME) * sPct
		pd.windSound.Pitch = cfg.WIND_MIN_PITCH + (cfg.WIND_MAX_PITCH - cfg.WIND_MIN_PITCH ) * sPct
	end

	-- [REMOVED] RE_Throttle:FireClient - Server sends this now
	-- [REMOVED] pd.plane:SetAttribute("CurrentThrottle", pd.throttle) -- Server handles this

	-- Gear toggle (uses tagged gear parts)
	if input.landing then
		pd.gear = not pd.gear -- Toggle local state
		gearToggleRemote:FireServer(pd.plane) -- Tell server to replicate
		input.landing = false -- Consume input
		-- [REMOVED] Visual loop - Server now handles this for all clients
	end

	-- Health/throttle multiplier
	pd.throttle = pd.throttle * (pd.plane:GetAttribute("ThrottleMultiplier") or 1.0)

	-- Speed model
	local vary = -pd.main.CFrame.LookVector.Y * (pd.speedVary or 0)
	local vmax = math.max(1, (pd.maxSpeed or 200) + vary)
	local forward = vmax * pd.throttle
	local brake = vmax * pd.brakeThrottle * cfg.BRAKE_FORCE_MULTIPLIER
	pd.desiredSpeed = forward + brake

	local change = (pd.desiredSpeed > pd.currentSpeed) and 1 or -1
	local ns = pd.currentSpeed + (pd.accel or 1) * change
	if change == 1 then
		pd.currentSpeed = math.min(ns, pd.desiredSpeed)
	else
		pd.currentSpeed = math.max(ns, math.max(pd.desiredSpeed, -20))
	end

	local stl = stall(pd)

	if pd.lastStall and not stl and not isTaxiing(pd) then
		if not pd.isBraking and pd.realSpeed > 10 and pd.realSpeed < pd.maxSpeed then
			local sd = pd.realSpeed - pd.currentSpeed
			pd.currentSpeed = pd.currentSpeed + (sd * 0.1)
		end
	end
	pd.lastStall = stl

	local onGround = Workspace:FindPartOnRay(Ray.new(pd.main.Position, Vector3.new(0, -pd.lowestPoint, 0)), pd.plane)

	if not onGround and pd.realSpeed > cfg.LANDING_MIN_AIR_SPEED then
		pd.hasBeenAirborne = true
	end
	if onGround and pd.hasBeenAirborne and pd.realSpeed > cfg.LANDING_DETECTION_SPEED and pd.landingTime == 0 then
		pd.landingTime = tick() -- Use tick() for time stamps
		pd.hasBeenAirborne = false
		local cap = cfg.MAX_SAFE_FORCE * 0.3
		pd.move.MaxForce = Vector3.new(cap, cap, cap)
	end

	local inGrace = false
	if pd.landingTime > 0 then
		if (tick() - pd.landingTime) < cfg.LANDING_GRACE_TIME then
			inGrace = true
		else
			pd.landingTime = 0
		end
	end

	-- Base velocity (forward along look vector)
	local baseVelocity = pd.main.CFrame.LookVector * pd.currentSpeed

	-- Stall downward clamp
	if stl and not onGround then
		if baseVelocity.Y < -80 then
			baseVelocity = Vector3.new(baseVelocity.X, -80, baseVelocity.Z)
		end
	end

	-- Orientation targets and authority
	local rawBank = (((input.viewSizeX/2) - input.mouseX) / math.max(1, (input.viewSizeX/2))) * pd.maxBank
	local bank = math.clamp(rawBank, -pd.maxBank, pd.maxBank)
	local groundCFrame = CFrame.new(pd.main.Position, input.mouseHitP)
	local flightCFrame = input.mouseHit * CFrame.Angles(0, 0, math.rad(bank))
	local targetCFrame = groundCFrame:Lerp(flightCFrame, transitionFactor)

	-- ===== v4.2 RECOVERY ASSIST =====
	local targetLookY = targetCFrame.LookVector.Y
	local noseUpIntent = math.clamp((-targetLookY - 0.02) / 0.6, 0, 1)
	local throttleIntent = math.clamp((pd.throttle - 0.5) / 0.5, 0, 1)
	local speedOK = (pd.currentSpeed >= (pd.cfg.STALL_SPEED * 0.85)) and 1 or 0
	local recoveryIntent = math.clamp(0.65 * noseUpIntent + 0.35 * throttleIntent, 0, 1) * speedOK

	local riseTau, decayTau = 0.20, 0.45
	local k = dt / ((recoveryIntent > pd.fallAssist) and riseTau or decayTau)
	k = math.clamp(k, 0, 1)
	pd.fallAssist = pd.fallAssist + (recoveryIntent - pd.fallAssist) * k
	-- ================================

	-- Fall term
	local fallSpeed = (1 - transitionFactor) * cfg.MAX_FALL_SPEED

	-- Reduce fall by recovery assist (up to ~90%)
	local effectiveFall = fallSpeed * (1 - 0.9 * pd.fallAssist)

	-- Prevent extreme combined downward velocity
	local totalDown = baseVelocity.Y - effectiveFall
	if totalDown < -150 then
		effectiveFall = effectiveFall * 0.5
	end

	-- Hard clamp forward magnitude before applying fall
	if baseVelocity.Magnitude > cfg.MAX_VELOCITY then
		baseVelocity = baseVelocity.Unit * cfg.MAX_VELOCITY
	end

	-- Gyro torque setup with sensitivities
	local F = cfg.MAX_SAFE_FORCE
	local pitchSensitivity = cfg.PITCH_SENSITIVITY or 1.0
	local bankSensitivity = cfg.BANK_SENSITIVITY or 1.0
	local targetPitchTorque = F * transitionFactor * pitchSensitivity
	local targetBankTorque = F * bankSensitivity

	-- ===== v4.2: terminal fall speed =====
	local TERMINAL_FALL_SPEED = cfg.TERMINAL_FALL_SPEED or 160
	-- ==========================================================

	if onGround then
		pd.move.Velocity = baseVelocity -- no falling while grounded

		if pd.currentSpeed < 2 then
			pd.move.MaxForce = Vector3.new(0, 0, 0)
			pd.gyro.MaxTorque = Vector3.new(0, 0, 0)
			pd.gyro.CFrame = groundCFrame
		elseif inGrace then
			pd.move.MaxForce = Vector3.new(F*0.1, F*0.05, F*0.1)
			pd.gyro.MaxTorque = Vector3.new(0, F*0.1, 0)
			pd.gyro.CFrame = groundCFrame
		else
			local forceMult = stl and 0.3 or 1.0
			local yAxisForce = F * transitionFactor * forceMult
			-- small Y-lift boost during recovery
			yAxisForce = yAxisForce * (1 + 0.25 * pd.fallAssist)

			pd.move.MaxForce = Vector3.new(F, yAxisForce, F)
			pd.gyro.MaxTorque = Vector3.new(targetPitchTorque, F, targetBankTorque)
			pd.gyro.CFrame = targetCFrame
		end
	else
		-- In the air: apply forward + reduced fall
		local vy = baseVelocity.Y - effectiveFall
		if vy < -TERMINAL_FALL_SPEED then
			vy = -TERMINAL_FALL_SPEED -- v4.2: cap commanded downward speed
		end
		pd.move.Velocity = Vector3.new(baseVelocity.X, vy, baseVelocity.Z)

		local forceMult = stl and 0.3 or 1.0
		local yAxisForce = F * transitionFactor * forceMult
		-- boost Y-lift under recovery assist (max +35%)
		yAxisForce = yAxisForce * (1 + 0.35 * pd.fallAssist)

		pd.move.MaxForce = Vector3.new(F * forceMult, yAxisForce, F * forceMult)
		pd.gyro.MaxTorque = Vector3.new(targetPitchTorque, F, targetBankTorque)
		pd.gyro.CFrame = targetCFrame

		-- Final downward clamp while airborne (safety)
		local v = pd.main.AssemblyLinearVelocity
		if v.Y < -TERMINAL_FALL_SPEED then
			pd.main.AssemblyLinearVelocity = Vector3.new(v.X, -TERMINAL_FALL_SPEED, v.Z)
		end
	end

	-- Hard velocity clamp (overall magnitude)
	local vel = pd.main.AssemblyLinearVelocity
	if vel.Magnitude > cfg.MAX_VELOCITY then
		pd.main.AssemblyLinearVelocity = vel.Unit * (cfg.MAX_VELOCITY * 0.8)
	end
end
-- ========================================================
-- [END] LOCAL PHYSICS UPDATE
-- ========================================================


-- ===== Camera System (New custom camera) =====
local function updatePlaneCamera(dt)
	if not flying or not currentPlane then return end

	local mainParts = currentPlane:FindFirstChild("MainParts")
	if not mainParts then return end

	local main = mainParts:FindFirstChild("Main")
	if not main then return end

	-- Initialize camera position if needed
	if not currentCameraPosition then
		currentCameraPosition = main.Position - main.CFrame.LookVector * CAMERA_DISTANCE + Vector3.new(0, CAMERA_HEIGHT, 0)
		currentCameraLookAt = main.Position
	end

	-- Desktop Panning: Smooth orbit return when not holding right-click
	if isDesktop and not isOrbiting then
		orbitX = orbitX * 0.9  -- Decay orbit back to center
		orbitY = orbitY * 0.9
		if math.abs(orbitX) < 0.005 then orbitX = 0 end
		if math.abs(orbitY) < 0.005 then orbitY = 0 end
	end

	-- Mobile is always centered, so orbit must be zeroed out
	if isMobile then
		orbitX = 0
		orbitY = 0
	end

	-- Calculate desired camera position (simple follow from behind)
	local desiredOffset = -main.CFrame.LookVector * currentZoom + Vector3.new(0, CAMERA_HEIGHT, 0)

	-- Apply orbit rotation if active (Desktop only)
	if isDesktop and (math.abs(orbitX) > 0.005 or math.abs(orbitY) > 0.005) then
		local yaw = CFrame.Angles(0, orbitX, 0)
		local pitch = CFrame.Angles(orbitY * 0.5, 0, 0)  -- Limit vertical orbit
		desiredOffset = yaw:VectorToWorldSpace(pitch:VectorToWorldSpace(desiredOffset))
	end

	local desiredCameraPosition = main.Position + desiredOffset
	local desiredLookAt = main.Position

	-- Smooth camera movement (prevents choppiness)
	currentCameraPosition = currentCameraPosition:Lerp(desiredCameraPosition, CAMERA_SMOOTHING)
	currentCameraLookAt = currentCameraLookAt:Lerp(desiredLookAt, CAMERA_SMOOTHING * 2) -- Look target moves faster

	-- Set camera CFrame
	camera.CFrame = CFrame.lookAt(currentCameraPosition, currentCameraLookAt)
end

local function startCamera()
	if not cameraConnection then
		-- Use RenderStepped for visual smoothness
		cameraConnection = RunService.RenderStepped:Connect(updatePlaneCamera)
	end
end

local function stopCamera()
	if cameraConnection then
		cameraConnection:Disconnect()
		cameraConnection = nil
	end
end
-- ===========================================

-- ===== GUI Animation (Existing Heartbeat loop) =====
RunService.Heartbeat:Connect(function()
	-- GUI updates (existing code)
	currentThrottle = currentThrottle + (targetThrottle - currentThrottle) * 0.15
	currentBrake    = currentBrake + (targetBrake    - currentBrake)    * 0.15
	currentRange    = currentRange + (targetRange    - currentRange)    * 0.05

	local throttleHeight = math.clamp(currentThrottle, 0, 1) * 300
	throttleBar.Size = UDim2.new(0, 26, 0, throttleHeight)

	if targetBrake > 0.01 or currentBrake > 0.01 then
		brakeBar.Visible = true
		local brakeHeight = math.clamp(currentBrake, 0, 1) * 300
		brakeBar.Size = UDim2.new(0, 26, 0, brakeHeight)
		brakeBar.BackgroundTransparency = 0.3
	else
		brakeBar.Visible = false
	end

	local rangeHeight = math.clamp(currentRange, 0, 1) * 300
	rangeBar.Size = UDim2.new(0, 26, 0, rangeHeight)
	if currentRange > 0.5 then
		rangeBar.BackgroundColor3 = Color3.fromRGB(100, 255, 100)
	elseif currentRange > 0.25 then
		local blend = (currentRange - 0.25) / 0.25
		rangeBar.BackgroundColor3 = Color3.fromRGB(255, 255, 100 * blend)
	else
		rangeBar.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
	end

	if currentThrottle > 0.95 then
		local pulse = math.sin(tick()*3)*0.2 + 0.3
		throttleBar.BackgroundTransparency = pulse
	else
		throttleBar.BackgroundTransparency = 0.3
	end

	if currentRange < 0.1 then
		local pulse = math.sin(tick()*5)*0.3 + 0.3
		rangeBar.BackgroundTransparency = pulse
	else
		rangeBar.BackgroundTransparency = 0.3
	end

	if gpHaveRecentLook then
		gpRightX = gpRightX * gpLookDecay
		gpRightY = gpRightY * gpLookDecay
		if math.abs(gpRightX) < 0.02 and math.abs(gpRightY) < 0.02 then
			gpHaveRecentLook = false
		end
	end
	if haveRecentTouchLook and (touchLookVec.Magnitude < 0.02) then
		haveRecentTouchLook = false
	end
end)

throttleRemote.OnClientEvent:Connect(function(throttle, brake, range)
	targetThrottle = throttle or 0
	targetBrake    = brake or 0
	targetRange    = range or 1
end)

-- ===== Seat monitoring (Modified to use CameraType.Scriptable AND build local pd table) =====
local function onSeatChanged(active, seat)
	if active and seat then
		local isPlane = seat:FindFirstChild("IsPlane")
		if not isPlane then return end
		local plane = seat.Parent and seat.Parent.Parent
		if not (plane and plane:FindFirstChild("MainParts")) then return end

		currentSeat = seat
		currentPlane = plane
		flying = true
		activateRemote:FireServer(plane, true)

		-- [NEW] Build the local plane data (pd) table
		pcall(function()
			local mainParts = currentPlane:FindFirstChild("MainParts")
			local main = mainParts:FindFirstChild("Main")
			local landing = mainParts:FindFirstChild("LandingGear")
			local cfg = require(currentPlane:FindFirstChild("PlaneConfig"))

			-- IMPORTANT: Wait for server to create Move and Gyro
			local move = main:WaitForChild("Move", 5)
			local gyro = main:WaitForChild("Gyro", 5)
			if not (move and gyro) then
				warn("❌ Failed to find Move/Gyro objects!")
				return
			end

			local gearParts = {}
			if landing then gearParts = setupGearParts(landing) end
			local lowestPoint = getLowestPoint(main, gearParts)

			-- Create local sounds
			local engineSound = mkSound(main, "EngineSound", cfg.ENGINE_SOUND_ID, cfg.ENGINE_MIN_VOLUME, cfg.ENGINE_MIN_PITCH, cfg.ENGINE_SOUND_ROLLOFF)
			local windSound = mkSound(main, "WindSound", cfg.WIND_SOUND_ID, 0, cfg.WIND_MIN_PITCH, cfg.WIND_SOUND_ROLLOFF)

			currentPlaneData = {
				plane = currentPlane, cfg = cfg, main = main, seat = currentSeat, landingGear = landing,
				move = move, gyro = gyro,
				gearParts = gearParts,
				lowestPoint = lowestPoint,

				accel = cfg.ACCELERATION,
				maxBank = math.clamp(cfg.MAX_BANK, -90, 90),
				maxSpeed = cfg.MAX_SPEED,
				speedVary = cfg.SPEED_DIFFERENTIAL,
				stallSpeed = math.min(cfg.STALL_SPEED, cfg.MAX_SPEED),

				desiredSpeed = 0, currentSpeed = 0, realSpeed = 0,

				throttle = 0, brakeThrottle = 0,
				fuelRange = currentPlane:GetAttribute("FuelRange") or 1.0,

				on = true, dead = false, gear = true, -- Assume gear down on entry

				lastPos = main.Position, lastTime = tick(), lastStall = false,
				isBraking = false, landingTime = 0, hasBeenAirborne = false,

				engineSound = engineSound,
				windSound = windSound,

				player = player,

				fallAssist = 0,
			}

			if currentPlaneData.engineSound then currentPlaneData.engineSound:Play() end
			if currentPlaneData.windSound then currentPlaneData.windSound:Play() end
		end)

		-- Use Scriptable camera for custom control (pan/zoom)
		workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable

		-- Reset camera state
		currentZoom = CAMERA_DISTANCE
		orbitX, orbitY = 0, 0
		currentCameraPosition = nil
		currentCameraLookAt = nil
		startCamera() -- Start the RenderStepped camera update loop

		gui.Enabled = true
		rangeBar.BackgroundTransparency = 1
		throttleBar.BackgroundTransparency = 1
		brakeBar.BackgroundTransparency = 1
		brakeBar.Visible = false

		TweenService:Create(rangeBar,   TweenInfo.new(0.5, Enum.EasingStyle.Quad), {BackgroundTransparency = 0.3}):Play()
		TweenService:Create(throttleBar,TweenInfo.new(0.5, Enum.EasingStyle.Quad), {BackgroundTransparency = 0.3}):Play()

		mobileHud.Enabled = isMobile

	else
		if flying then
			flying = false

			stopCamera() -- Stop the RenderStepped camera loop
			workspace.CurrentCamera.CameraType = Enum.CameraType.Custom -- Restore player camera

			-- [NEW] Clean up local sounds and pd table
			if currentPlaneData then
				if currentPlaneData.engineSound then currentPlaneData.engineSound:Destroy() end
				if currentPlaneData.windSound then currentPlaneData.windSound:Destroy() end
				currentPlaneData = nil
			end

			if currentPlane then
				activateRemote:FireServer(currentPlane, false)
			end
			currentSeat, currentPlane = nil, nil

			TweenService:Create(rangeBar,   TweenInfo.new(0.5, Enum.EasingStyle.Quad), {BackgroundTransparency = 1}):Play()
			TweenService:Create(throttleBar,TweenInfo.new(0.5, Enum.EasingStyle.Quad), {BackgroundTransparency = 1}):Play()
			if brakeBar.Visible then
				TweenService:Create(brakeBar, TweenInfo.new(0.5, Enum.EasingStyle.Quad), {BackgroundTransparency = 1}):Play()
			end
			task.delay(0.55, function()
				gui.Enabled = false
				mobileHud.Enabled = false
				currentThrottle, currentBrake, targetThrottle, targetBrake = 0,0,0,0
				currentRange, targetRange = 1,1
				brakeBar.Visible = false
			end)
		end
	end
end

player.CharacterAdded:Connect(function(character)
	local humanoid = character:WaitForChild("Humanoid")
	humanoid.Seated:Connect(onSeatChanged)
end)
if player.Character then
	local humanoid = player.Character:FindFirstChild("Humanoid")
	if humanoid then humanoid.Seated:Connect(onSeatChanged) end
end

-- ===== MODIFIED: Continuous PHYSICS loop (Runs on Heartbeat for correct timing) =====
local lastPhysicsUpdate = tick()
task.spawn(function()
	while true do
		-- Use Heartbeat instead of RenderStepped to match original physics timing
		RunService.Heartbeat:Wait()

		local now = tick()
		local dt = now - lastPhysicsUpdate
		lastPhysicsUpdate = now

		if flying and currentPlane and currentPlaneData then
			-- 1. Get aim input
			local mx, my, vx, vy, mHit, mHitP = getAim()

			-- 2. Create input table
			local input = {
				mouseX = mx,
				mouseY = my,
				viewSizeX = vx,
				viewSizeY = vy,
				mouseHit = mHit,
				mouseHitP = mHitP,
				throttleUp = keys.spdup.down,
				throttleDown = keys.spddwn.down,
				landing = keys.landing.down
			}

			-- 3. Run the local physics simulation
			pcall(update, currentPlaneData, input, dt)

			-- 4. Sync throttle with server for fuel consumption (every 10 frames to reduce network spam)
			if tick() % 0.1 < dt then
				throttleSyncRemote:FireServer(currentPlane, currentPlaneData.throttle)
			end

			-- 5. Consume the 'landing' key press
			if keys.landing.down then keys.landing.down = false end

		end
	end
end)

-- ===== Input Handling (Zoom and Panning - Desktop Only) =====

-- Mouse wheel zoom (Desktop Only)
UserInputService.InputChanged:Connect(function(input, gameProcessed)
	if not flying or gameProcessed or not isDesktop then return end

	if input.UserInputType == Enum.UserInputType.MouseWheel then
		-- Apply zoom limits
		currentZoom = math.clamp(currentZoom - input.Position.Z * ZOOM_SPEED, MIN_ZOOM, MAX_ZOOM)
	end
end)

-- Right-click orbit (Desktop Only)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if not flying or gameProcessed or not isDesktop then return end

	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		isOrbiting = true
		lastMouseX = mouse.X
		lastMouseY = mouse.Y
	end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		isOrbiting = false
	end
end)

-- Mouse movement for orbit (Desktop Only)
mouse.Move:Connect(function()
	if not flying or not isOrbiting or not isDesktop then return end

	local deltaX = (mouse.X - lastMouseX) * ORBIT_SENSITIVITY * 0.01
	local deltaY = (mouse.Y - lastMouseY) * ORBIT_SENSITIVITY * 0.01

	orbitX = orbitX - deltaX
	orbitY = math.clamp(orbitY - deltaY, -1, 1)

	lastMouseX = mouse.X
	lastMouseY = mouse.Y
end)


-- ===== Keyboard (PC) (Existing) =====
mouse.KeyDown:Connect(function(k)
	if not flying then return end
	k = k:lower()
	if k == "g" then
		keys.landing.down = true -- This is now a "trigger"
	elseif k == "w" or k:byte() == 17 then
		keys.spdup.down = true
	elseif k == "s" or k:byte() == 18 then
		keys.spddwn.down = true
	end
end)
mouse.KeyUp:Connect(function(k)
	k = k:lower()
	if k == "g" then
		keys.landing.down = false
	elseif k == "w" or k:byte() == 17 then
		keys.spdup.down = false
	elseif k == "s" or k:byte() == 18 then
		keys.spddwn.down = false
	end
end)

-- ===== Mobile touch controls (Existing buttons) =====
local function bindMobileButtons()
	throttleUpBtn.MouseButton1Down:Connect(function()
		if flying then keys.spdup.down = true end
	end)
	throttleUpBtn.MouseButton1Up:Connect(function()
		keys.spdup.down = false
	end)
	throttleUpBtn.TouchLongPress:Connect(function(_,state)
		-- Original v4.0 used Enum.LongPressState, check if this is correct
		-- Corrected based on later versions to UserInputState
		if state == Enum.UserInputState.Begin then keys.spdup.down = true end
		if state == Enum.UserInputState.End   then keys.spdup.down = false end
	end)

	throttleDownBtn.MouseButton1Down:Connect(function()
		if flying then keys.spddwn.down = true end
	end)
	throttleDownBtn.MouseButton1Up:Connect(function()
		keys.spddwn.down = false
	end)
	throttleDownBtn.TouchLongPress:Connect(function(_,state)
		-- Corrected based on later versions to UserInputState
		if state == Enum.UserInputState.Begin then keys.spddwn.down = true end
		if state == Enum.UserInputState.End   then keys.spddwn.down = false end
	end)

	gearBtn.MouseButton1Click:Connect(function()
		if flying then
			keys.landing.down = true -- Set trigger
			-- No delay needed, RenderStepped loop will consume it
		end
	end)
end
bindMobileButtons()

-- ========================================================================
-- ===== MOBILE STEERING SECTION - NEEDS IMPLEMENTATION =====
-- ========================================================================
-- The original v4.0 right-side drag logic below only updated a 2D vector
-- (`touchLookVec`) which was used by `getAim` to calculate a steering
-- direction. This direction was often inaccurate or caused instability.
--
-- Attempts to fix this included:
-- 1. Tap-to-Steer: Tapping sets a static 3D world point.
--    - Problem: Plane often circled the point or flew erratically because
--      the server physics expects constantly updated input like a mouse.
-- 2. Release-to-Hold-Target: Tapping/Dragging sets a 3D point, releasing
--    keeps flying towards the *last* point.
--    - Problem: Still unstable, likely due to CFrame orientation mismatch
--      or gyro expecting dynamic updates.
-- 3. Drag-to-Steer (like Desktop): Holding and dragging updates the 3D target.
--    - Problem: Unstable flight. Various CFrame calculation methods tried:
--      - CFrame.new(pos, pos + normal) for ground, CFrame.lookAt(pos, cameraPos) for sky
--      - CFrame.fromMatrix using camera UpVector for sky
--      - CFrame.new(pos) with identity rotation for sky
--    - None provided stable flight matching desktop mouse control.
-- 4. Client-Side Smoothing (Lerp): Added Lerp to the Drag-to-Steer CFrame.
--    - Problem: Either too sluggish or still unstable depending on factor.
--
-- Conclusion: A different approach is likely needed. Perhaps a virtual joystick
-- that directly controls pitch/yaw/roll inputs instead of calculating a 3D
-- target point, or modifications to the server script to handle mobile's
-- potentially less precise CFrame data differently.
-- ========================================================================

-- Original v4.0 Right-side drag = look (Used for aiming/steering on mobile)
UserInputService.TouchStarted:Connect(function(touch, gp)
	if not flying then return end
	local vp = workspace.CurrentCamera.ViewportSize
	if touch.Position.X > vp.X * 0.55 then
		touchLookId = touch.UserInputState -- Fixed: Use UserInputState instead of InstanceId
		touchLookVec = Vector2.new()
		haveRecentTouchLook = true
	end
end)
UserInputService.TouchMoved:Connect(function(touch, gp)
	if not flying then return end
	if touchLookId and touch.UserInputState == touchLookId then -- Fixed: Use UserInputState
		local delta = touch.Delta
		touchLookVec = touchLookVec + Vector2.new(delta.X, delta.Y) * 0.002
		touchLookVec = Vector2.new(math.clamp(touchLookVec.X, -1, 1), math.clamp(touchLookVec.Y, -1, 1))
		haveRecentTouchLook = true
	end
end)
UserInputService.TouchEnded:Connect(function(touch, gp)
	if touchLookId and touch.UserInputState == touchLookId then -- Fixed: Use UserInputState
		touchLookId = nil
	end
end)

-- ===== Console (gamepad) (Existing) =====
local function gamepadActionThrottleUp(actionName, inputState, inputObj)
	if not flying then return Enum.ContextActionResult.Pass end
	if inputState == Enum.UserInputState.Begin then keys.spdup.down = true
	elseif inputState == Enum.UserInputState.End then keys.spdup.down = false end
	return Enum.ContextActionResult.Sink
end
local function gamepadActionThrottleDown(actionName, inputState, inputObj)
	if not flying then return Enum.ContextActionResult.Pass end
	if inputState == Enum.UserInputState.Begin then keys.spddwn.down = true
	elseif inputState == Enum.UserInputState.End then keys.spddwn.down = false end
	return Enum.ContextActionResult.Sink
end
local function gamepadActionGear(actionName, inputState, inputObj)
	if not flying then return Enum.ContextActionResult.Pass end
	if inputState == Enum.UserInputState.Begin then
		keys.landing.down = true
	elseif inputState == Enum.UserInputState.End then
		keys.landing.down = false -- This is now a trigger
	end
	return Enum.ContextActionResult.Sink
end

ContextActionService:BindAction("Plane_ThrottleUp", gamepadActionThrottleUp, false, Enum.KeyCode.ButtonR2)
ContextActionService:BindAction("Plane_ThrottleDown", gamepadActionThrottleDown, false, Enum.KeyCode.ButtonL2)
ContextActionService:BindAction("Plane_Gear", gamepadActionGear, false, Enum.KeyCode.ButtonY)

UserInputService.InputChanged:Connect(function(input, gp)
	if not flying then return end
	if input.UserInputType == Enum.UserInputType.Gamepad1 and input.KeyCode == Enum.KeyCode.Thumbstick2 then
		local v = input.Position
		gpRightX = v.X
		gpRightY = v.Y
		if math.abs(gpRightX) > 0.05 or math.abs(gpRightY) > 0.05 then
			gpHaveRecentLook = true
		end
	end
end)

print("✅ CLIENT PLANE INPUT: Loaded (v4.2 LOCAL PHYSICS - Mobile steering needs implementation)")
