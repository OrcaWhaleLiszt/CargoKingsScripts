--[[
OrcaCreations UnifiedPlanePhysics v4.2
(Realistic Takeoff + Recovery Assist + Terminal Fall Clamp)

Author: GPT-5 Thinking (ChatGPT)
Placement: ServerScriptService (centralized for all planes)

Combined with v4.4 Refuel Module (by Gemini)
- Physics are 100% v4.2 (assisted fall)
- Refuel logic is from v4.4 (standalone)

MODIFIED: Physics calculations (update function) moved to client for smoothness.
Server now only handles fuel, gear replication, and network ownership.
]]--

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local ServerScriptService = game:GetService("ServerScriptService")

-- Remotes
local Remotes = ReplicatedStorage:WaitForChild("PlaneRemotes", 10)
if not Remotes then error("❌ ReplicatedStorage.PlaneRemotes missing") end
local RE_Input = Remotes:WaitForChild("PlaneInput", 10) -- Kept for compatibility, but unused by v4.2 physics
local RE_Activate = Remotes:FindFirstChild("PlaneActivate") -- optional
local RE_Throttle = Remotes:FindFirstChild("ThrottleUpdate") -- optional

-- NEW REMOTES FOR CLIENT-SIDED PHYSICS
local RE_GearToggle = Remotes:WaitForChild("RE_GearToggle", 10)
local RE_ThrottleSync = Remotes:WaitForChild("RE_ThrottleSync", 10)
local RE_PlaneCrash = Remotes:WaitForChild("PlaneCrash", 10)
if not (RE_GearToggle and RE_ThrottleSync and RE_PlaneCrash) then error("❌ Missing RE_GearToggle, RE_ThrottleSync, or PlaneCrash in PlaneRemotes") end


-- Optional notification + data systems
local NotificationEvents = nil
task.spawn(function()
	pcall(function()
		local RE = ReplicatedStorage:FindFirstChild("RemoteEvents")
		if RE then NotificationEvents = RE:FindFirstChild("NotificationEvents") end
	end)
end)

local DataManager = nil
task.spawn(function()
	pcall(function()
		local ck = ServerScriptService:WaitForChild("CargoKingsServer", 5)
		if ck then DataManager = require(ck:WaitForChild("DataManager", 5)) end
	end)
end)

-- ======= Local tuning (non-physics) =======
local PROMPT_NAMES = { "PlaneProximityPrompt", "PlaneProximtyPrompt", "ProximityPrompt" }
local PROMPT_RADIUS = 18
local PROMPT_DEFAULT_HOLD = 1.0 -- default if PlaneConfig omits

-- =======================
-- [REFUEL ADDITION]
-- =======================
local REFUEL_RADIUS_STUDS      = 250        -- how close to refuel
local REFUEL_RATE_PER_SEC      = 0.02       -- +2% per second → adds dt*rate
local REFUEL_CHECK_INTERVAL    = 1.0        -- don't scan too often
local REFUEL_TAG               = "RefuelStation" -- optional; uses tag if found, else name check
-- =======================
-- [END REFUEL ADDITION]
-- =======================

-- Cargo Kings seat/cargo config
local DEFAULT_MAX_CARGO_KILOS = 50
local PROMPT_DISTANCE = 10

-- ========================================================
-- [WELDING CODE - UNTOUCHED FROM V2.4]
-- ========================================================
local function isPlaneModel(m: Instance): boolean
	if not m or not m:IsA("Model") then return false end
	if not m:FindFirstChild("PlaneConfig") then return false end
	local mp = m:FindFirstChild("MainParts")
	if not mp then return false end
	local main = mp:FindFirstChild("Main")
	return (main and main:IsA("BasePart"))
end

local function safeRequire(ms: Instance)
	local ok, mod = pcall(require, ms)
	if ok then return mod end
	warn(("⚠️ require failed %s: %s"):format(ms:GetFullName(), tostring(mod)))
	return nil
end

local function collectParts(root: Instance): {BasePart}
	local out = {}
	for _, d in ipairs(root:GetDescendants()) do
		if d:IsA("BasePart") then
			table.insert(out, d)
		end
	end
	return out
end

local function shouldSkipForWeld(part: BasePart): boolean
	local n = part.Name:lower()
	if n:find("propeller") or n:find("prop_") or n:find("rotor") or n:find("spinner") then
		return true
	end
	for _, c in ipairs(part:GetDescendants()) do
		if c:IsA("HingeConstraint") or c:IsA("Motor6D") then
			return true
		end
	end
	return false
end

-- Transactional weld (create constraints first, then unanchor)
local function centralWeldOnce(plane: Model, main: BasePart)
	if plane:GetAttribute("__Welded") then return end

	local allParts = collectParts(plane)
	local toWeld: {BasePart} = {}
	for _, bp in ipairs(allParts) do
		if bp ~= main and not shouldSkipForWeld(bp) then
			table.insert(toWeld, bp)
		end
	end

	-- Clear existing weld-like things
	for _, bp in ipairs(toWeld) do
		for _, c in ipairs(bp:GetChildren()) do
			if c:IsA("Weld") or c:IsA("Snap") or c:IsA("WeldConstraint") then
				c:Destroy()
			end
		end
	end

	-- Re-weld to main
	for _, bp in ipairs(toWeld) do
		local wc = Instance.new("WeldConstraint")
		wc.Part0 = main
		wc.Part1 = bp
		wc.Parent = main
	end

	-- Unanchor all
	for _, bp in ipairs(allParts) do
		bp.Anchored = false
		if bp.Massless then bp.Massless = false end
	end

	plane:SetAttribute("__Welded", true)
end
-- ========================================================
-- [END WELDING CODE]
-- ========================================================

local function findPromptOnSeat(seat: Instance)
	for _, name in ipairs(PROMPT_NAMES) do
		local p = seat:FindFirstChild(name)
		if p and p:IsA("ProximityPrompt") then return p end
	end
	return nil
end

-- Types
type PD = {
	plane: Model,
	cfg: any,
	main: BasePart,
	seat: Seat?,
	landingGear: Instance?,

	gearParts: {BasePart}, -- Added from v4.4 init logic

	move: BodyVelocity,
	gyro: BodyGyro,

	-- accel: number, -- Client handles
	-- maxBank: number, -- Client handles
	-- maxSpeed: number, -- Client handles
	-- speedVary: number, -- Client handles
	-- stallSpeed: number, -- Client handles

	-- desiredSpeed: number, -- Client handles
	-- currentSpeed: number, -- Client handles
	-- realSpeed: number, -- Client handles

	throttle: number, -- Synced from client for fuel drain
	-- brakeThrottle: number, -- Client handles
	fuelRange: number,

	on: boolean,
	dead: boolean,
	gear: boolean,

	-- lastPos: Vector3, -- Client handles
	-- lastTime: number, -- Client handles
	-- lastStall: boolean, -- Client handles
	-- isBraking: boolean, -- Client handles
	-- landingTime: number, -- Client handles
	-- hasBeenAirborne: boolean, -- Client handles
	lowestPoint: number,

	-- engineSound: Sound?, -- Client handles
	-- windSound: Sound?, -- Client handles

	player: Player?,

	-- v4.2
	-- fallAssist: number, -- Client handles

	-- [REFUEL ADDITION]
	lastRefuelCheck: number,
	currentRefuelStation: BasePart?,
}

local registry: {[Model]: PD} = {}

-- Re-uses existing movers, does not destroy valid ones
local function findOrCreateBodyMovers(main: BasePart): (BodyVelocity, BodyGyro)
	local move = main:FindFirstChild("Move")
	if not (move and move:IsA("BodyVelocity")) then
		if move then move:Destroy() end
		move = Instance.new("BodyVelocity")
		move.Name = "Move"
		move.Velocity = Vector3.zero
		move.MaxForce = Vector3.zero
		move.Parent = main
	end

	local gyro = main:FindFirstChild("Gyro")
	if not (gyro and gyro:IsA("BodyGyro")) then
		if gyro then gyro:Destroy() end
		gyro = Instance.new("BodyGyro")
		gyro.Name = "Gyro"
		gyro.MaxTorque = Vector3.zero
		gyro.CFrame = main.CFrame
		gyro.Parent = main
	end

	return move, gyro
end

-- Setup gear parts tags
local function setupGearParts(landingGearInstance)
	local gearParts = {}
	local function getGear(p)
		for _,v in ipairs(p:GetChildren()) do
			if v:IsA("BasePart") then
				if not v:FindFirstChild("Trans") then
					local t = Instance.new("NumberValue", v); t.Name="Trans"; t.Value=v.Transparency
					local r = Instance.new("NumberValue", v); r.Name="Ref"; r.Value=v.Reflectance
					local c = Instance.new("BoolValue", v); c.Name="Collide"; c.Value=v.CanCollide
				end
				table.insert(gearParts, v)
			end
			getGear(v)
		end
	end
	getGear(landingGearInstance)
	return gearParts
end

-- Lowest point calc
local function getLowestPoint(main, gearParts)
	local lowestPoint = 0
	if #gearParts == 0 then
		lowestPoint = (main.Position.Y + 5 + (main.Size.Y/2))
	else
		for _,v in ipairs(gearParts) do
			local _0 = (main.Position.Y-(v.CFrame*CFrame.new((v.Size.X/2),0,0)).Y)
			local _1 = (main.Position.Y-(v.CFrame*CFrame.new(-(v.Size.X/2),0,0)).Y)
			local _2 = (main.Position.Y-(v.CFrame*CFrame.new(0,(v.Size.Y/2),0)).Y)
			local _3 = (main.Position.Y-(v.CFrame*CFrame.new(0,-(v.Size.Y/2),0)).Y)
			local _4 = (main.Position.Y-(v.CFrame*CFrame.new(0,0,(v.Size.Z/2))).Y)
			local _5 = (main.Position.Y-(v.CFrame*CFrame.new(0,0,-(v.Size.Z/2))).Y)
			local n = (math.max(_0,_1,_2,_3,_4,_5)+5)
			if n > lowestPoint then lowestPoint = n end
		end
	end
	return lowestPoint
end

local function initPlane(model: Model): PD?
	if not isPlaneModel(model) then return nil end

	local mp = model:FindFirstChild("MainParts")
	if not mp then
		warn("Plane init failed: MainParts missing on "..model:GetFullName())
		return nil
	end

	local main = mp:FindFirstChild("Main") :: BasePart
	local seat = mp:FindFirstChild("MainSeat") :: Seat
	local landing = mp:FindFirstChild("LandingGear")

	-- [WELDING - UNTOUCHED]
	centralWeldOnce(model, main)

	local cfg = safeRequire(model:FindFirstChild("PlaneConfig"))
	if not cfg then return nil end

	local move, gyro = findOrCreateBodyMovers(main)

	-- Setup gear parts and lowest point
	local gearParts = {}
	if landing then
		gearParts = setupGearParts(landing)
	end
	local lowestPoint = getLowestPoint(main, gearParts)

	-- SOUNDS REMOVED - Client will create these
	-- local function mkSound(...)
	-- ...

	local pd: PD = {
		plane = model, cfg = cfg, main = main, seat = seat, landingGear = landing,
		move = move, gyro = gyro,
		gearParts = gearParts,
		lowestPoint = lowestPoint,

		-- All physics values removed (client handles)
		-- accel = cfg.ACCELERATION,
		-- maxBank = math.clamp(cfg.MAX_BANK, -90, 90),
		-- ...

		throttle = 0, -- Only for fuel drain
		fuelRange = model:GetAttribute("FuelRange") or 1.0,

		on = false, dead = false, gear = true,

		-- Physics state removed (client handles)
		-- lastPos = main.Position, lastTime = tick(), lastStall = false,
		-- ...

		-- Sounds removed (client handles)
		-- engineSound = mkSound(...)
		-- windSound = mkSound(...)

		player = nil,

		-- fallAssist = 0, -- Client handles

		-- [REFUEL ADDITION]
		lastRefuelCheck = 0,
		currentRefuelStation = nil,
	}

	-- Disable vanilla sitting; we will briefly enable when boarding
	if pd.seat and pd.seat:IsA("Seat") then
		pd.seat.Disabled = true
	end

	registry[model] = pd
	return pd
end

-- Helpers
-- [Client-side physics helpers removed - calculateTransition, isTaxiing, stall]

-- Activation
local function setForceCaps(pd: PD, on: boolean)
	local cap = pd.cfg.MAX_SAFE_FORCE
	if on then
		-- Set high caps, client will control the actual force/velocity
		pd.move.MaxForce = Vector3.new(cap, cap, cap)
		pd.gyro.MaxTorque = Vector3.new(cap, cap, cap)
	else
		pd.move.MaxForce = Vector3.zero
		pd.gyro.MaxTorque = Vector3.zero
	end
end

local function activate(pd: PD, plr: Player)
	if pd.on then return end
	pd.on = true
	pd.player = plr

	pd.main.Anchored = false
	task.wait(0.05)
	pcall(function() pd.main:SetNetworkOwner(plr) end)

	setForceCaps(pd, true)

	-- Sounds removed (client handles)
	-- if pd.engineSound then pd.engineSound:Play() end
	-- if pd.windSound then pd.windSound:Play() end
	if RE_Activate then pcall(function() RE_Activate:FireClient(plr, pd.plane, true) end) end
end

local function deactivate(pd: PD)
	if not pd.on then return end
	local cap = pd.cfg.MAX_SAFE_FORCE
	for i = 5, 1, -1 do
		if registry[pd.plane] ~= pd then return end
		local f = (i/5)*0.2
		pd.move.MaxForce = Vector3.new(cap, cap, cap) * f
		-- [Modified] Removed check for isTaxiing since server doesn't know
		pd.gyro.MaxTorque = Vector3.new(cap, cap, cap) * f
		task.wait(0.05)
	end
	setForceCaps(pd, false)
	pd.move.Velocity = Vector3.zero
	pd.gyro.CFrame = pd.main.CFrame
	pcall(function() pd.main:SetNetworkOwnershipAuto() end)

	-- Sounds removed (client handles)
	-- if pd.engineSound then pd.engineSound:Stop() end
	-- if pd.windSound then pd.windSound:Stop() end
	if RE_Activate and pd.player then pcall(function() RE_Activate:FireClient(pd.player, pd.plane, false) end) end
	pd.on = false
	pd.player = nil
	pd.throttle = 0 -- Stop fuel drain
	pd.plane:SetAttribute("CurrentThrottle", 0)
end

-- =======================
-- [REFUEL ADDITION - HELPER FUNCTIONS]
-- =======================
local function iterRefuelStations()
	-- Prefer CollectionService tag; fallback to scanning by name
	local stations = {}
	local ok, err = pcall(function()
		local CS = game:GetService("CollectionService")
		for _, inst in ipairs(CS:GetTagged(REFUEL_TAG)) do
			if inst:IsA("BasePart") then table.insert(stations, inst) end
		end
	end)
	if ok and #stations > 0 then
		return stations
	end

	-- Fallback: name-based search (any BasePart named "RefuelStation")
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("BasePart") and obj.Name == REFUEL_TAG then
			table.insert(stations, obj)
		end
	end
	return stations
end

local function findNearestRefuelStation(fromPos, maxDist)
	local nearest, best = nil, maxDist or REFUEL_RADIUS_STUDS
	for _, part in ipairs(iterRefuelStations()) do
		local d = (part.Position - fromPos).Magnitude
		if d < best then
			nearest, best = part, d
		end
	end
	return nearest, best
end

-- pd fields expected:
-- pd.plane            : Model
-- pd.main             : BasePart
-- pd.lastRefuelCheck  : number (tick)
-- pd.currentRefuelStation : BasePart|nil
local function stepRefuel(pd: PD, now: number)
	if not pd or not pd.main or not pd.plane then return end

	-- Initialize lastRefuelCheck if it's 0
	if pd.lastRefuelCheck == 0 then
		pd.lastRefuelCheck = now
	end

	-- Respect check interval
	if (now - pd.lastRefuelCheck) < REFUEL_CHECK_INTERVAL then return end
	local dt = (now - pd.lastRefuelCheck)
	pd.lastRefuelCheck = now

	-- Look for the closest eligible station
	local station, dist = findNearestRefuelStation(pd.main.Position, REFUEL_RADIUS_STUDS)
	if not station then
		pd.currentRefuelStation = nil
		return
	end

	-- Within radius → add fuel proportional to dt
	local currentFuel = pd.plane:GetAttribute("FuelRange") or 0
	if currentFuel >= 1 then
		pd.currentRefuelStation = station
		return
	end

	local add = REFUEL_RATE_PER_SEC * dt
	local newFuel = math.clamp(currentFuel + add, 0, 1)
	pd.plane:SetAttribute("FuelRange", newFuel)

	pd.currentRefuelStation = station
end
-- =======================
-- [END REFUEL ADDITION]
-- =======================

-- =======================
-- [CARGO KINGS - UNTOUCHED]
-- =======================
local function getCargoKilos(player: Player, pd: PD): number
	if DataManager then
		local pdata = DataManager.GetPlayerData(player)
		return (pdata and pdata.StudsOnPlayer) or 0
	end
	return 0
end

local function canBoard(player: Player, pd: PD): (boolean, number, number)
	local limit = (pd.cfg and pd.cfg.MAX_CARGO_KILOS) or DEFAULT_MAX_CARGO_KILOS
	local kilos = getCargoKilos(player, pd)
	return kilos <= limit, kilos, limit
end

local function notify(player: Player, message: string, kind: string?)
	if NotificationEvents then
		pcall(function() NotificationEvents:FireClient(player, kind or "Info", message) end)
	else
		print(("📢 [%s] %s"):format(player.Name, message))
	end
end

local function isPlayerOccupant(pd: PD, player: Player): boolean
	local occ = pd.seat and pd.seat.Occupant
	if not occ or not occ.Parent then return false end
	local plr = Players:GetPlayerFromCharacter(occ.Parent)
	return plr == player
end

local function warpAndSit(player: Player, pd: PD): boolean
	if not (pd.seat and pd.seat:IsA("Seat")) then return false end

	local char = player.Character
	if not (char and char.Parent) then return false end
	local hum = char:FindFirstChildOfClass("Humanoid")
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not (hum and hrp) then return false end

	-- Move avatar to seat position (slightly above) and zero velocity
	local seatCF = pd.seat.CFrame
	local target = seatCF * CFrame.new(0, 2.0, -0.5) -- drop into the seat
	hrp.CFrame = target
	if hrp.AssemblyLinearVelocity then hrp.AssemblyLinearVelocity = Vector3.zero end

	pd.seat.Disabled = false
	pd.seat:Sit(hum)

	return true
end

-- =======================
-- [PHYSICS UPDATE V4.2 - REMOVED]
-- =======================
-- The 'update(pd, input)' function has been moved to ClientPlaneInput.lua
-- The server no longer runs physics calculations.

-- =======================
-- [BOOTSTRAP - MODIFIED]
-- =======================

-- REMOVED: RE_Input.OnServerEvent
-- The client now runs physics locally.

if RE_Activate then
	RE_Activate.OnServerEvent:Connect(function(plr, planeModel, active)
		local pd = registry[planeModel]
		if not pd then return end
		if active then activate(pd, plr) else deactivate(pd) end
	end)
end

-- NEW: Listen for client gear toggle
RE_GearToggle.OnServerEvent:Connect(function(plr, planeModel)
	local pd = registry[planeModel]
	if not pd or pd.player ~= plr then return end

	-- This logic is copied from the old 'update' function
	-- to replicate gear state to all clients.
	pd.gear = not pd.gear
	for _,v in ipairs(pd.gearParts or {}) do
		local t = v:FindFirstChild("Trans")
		local r = v:FindFirstChild("Ref")
		local c = v:FindFirstChild("Collide")
		if t and r and c then
			v.Transparency = (pd.gear and t.Value or 1)
			v.Reflectance = (pd.gear and r.Value or 0)
			v.CanCollide = (pd.gear and c.Value or false)
		end
	end
end)

-- NEW: Listen for client throttle sync (for fuel drain)
RE_ThrottleSync.OnServerEvent:Connect(function(plr, planeModel, throttleValue)
	local pd = registry[planeModel]
	if not pd or pd.player ~= plr then return end

	-- Only store the throttle. The Heartbeat loop will handle consumption.
	pd.throttle = (throttleValue or 0)
	pd.plane:SetAttribute("CurrentThrottle", pd.throttle)
end)

-- ========================================================
-- [NEW] CRASH DETECTION HANDLER
-- ========================================================
RE_PlaneCrash.OnServerEvent:Connect(function(plr, planeModel)
	print("💥 Server received crash event from: " .. plr.Name)

	if not planeModel or not planeModel:IsA("Model") then
		warn("❌ Invalid plane model received")
		return
	end

	local pd = registry[planeModel]
	if not pd then
		warn("❌ Plane not found in registry: " .. planeModel.Name)
		return
	end

	if pd.player ~= plr then
		warn("❌ Player mismatch - expected: " .. (pd.player and pd.player.Name or "nil") .. ", got: " .. plr.Name)
		return
	end

	print("💥 Server handling crash for: " .. pd.plane.Name)

	-- Force deactivate physics
	if pd.on then
		deactivate(pd)
	end

	-- Create explosion at plane position
	local explosion = Instance.new("Explosion")
	explosion.Position = pd.main.Position
	explosion.BlastRadius = 50
	explosion.BlastPressure = 500000
	explosion.Parent = workspace
	print("💥 Explosion created at: " .. tostring(pd.main.Position))

	-- Kill the player
	local char = plr.Character
	if char then
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.Health = 0
			print("💀 Player killed in crash: " .. plr.Name)
		else
			warn("❌ No humanoid found for: " .. plr.Name)
		end
	else
		warn("❌ No character found for: " .. plr.Name)
	end

	-- Clean up plane after 5 seconds
	task.delay(5, function()
		if pd.plane and pd.plane.Parent then
			print("🧹 Cleaning up crashed plane: " .. pd.plane.Name)
			registry[pd.plane] = nil
			pd.plane:Destroy()
		end
	end)
end)
-- ========================================================
-- [END CRASH DETECTION HANDLER]
-- ========================================================


-- Prompt + seat
local function bindPrompt(pd: PD)
	if not pd.seat or not pd.seat:IsA("Seat") then return end

	-- Use existing prompt if present; else create
	local prompt = findPromptOnSeat(pd.seat)
	if not prompt then
		prompt = Instance.new("ProximityPrompt")
		prompt.Name = "PlaneProximityPrompt"
		prompt.Parent = pd.seat
	end

	-- Respect PlaneConfig.HoldDuration (default 1s)
	local hold = (pd.cfg and pd.cfg.PROMPT_HOLD_DURATION) or PROMPT_DEFAULT_HOLD
	prompt.ActionText = (pd.cfg and pd.cfg.PROMPT_TEXT) or "Pilot Plane"
	prompt.HoldDuration = hold
	prompt.KeyboardKeyCode = Enum.KeyCode.E
	prompt.GamepadKeyCode = Enum.KeyCode.ButtonX
	prompt.MaxActivationDistance = PROMPT_RADIUS
	prompt.RequiresLineOfSight = false
	prompt.Enabled = true

	-- Boarding flow with cargo gating
	prompt.Triggered:Connect(function(p: Player)
		-- If occupied, ignore
		if pd.seat.Occupant then return end

		-- Cargo rule
		local ok, kilos, limit = canBoard(p, pd)
		if not ok then
			notify(p, string.format("Cannot board: too much cargo (%.0f / %.0f kg). Deliver first.", kilos, limit), "CargoTooHeavy")
			return
		end

		-- Try to seat (warp + Sit), but don't announce success yet
		local attempted = warpAndSit(p, pd)

		-- Fail-safe: if not seated within 1.0s, tell them to retry
		task.delay(1.0, function()
			if pd.seat and not isPlayerOccupant(pd, p) then
				notify(p, "Boarding failed. Move closer and try again.", "Warning")
			end
		end)
	end)

	-- Keep prompt hidden while occupied; activate/deactivate physics on seat change
	local function updateSeatState()
		local occ = pd.seat.Occupant
		if occ then
			prompt.Enabled = false
			local char = occ.Parent
			if char then
				local plr = Players:GetPlayerFromCharacter(char)
				if plr then
					activate(pd, plr)
					notify(plr, "Seated. Prepare for taxi.", "Info")
				end
			end
		else
			prompt.Enabled = true
			if pd.on then deactivate(pd) end
		end
	end
	pd.seat:GetPropertyChangedSignal("Occupant"):Connect(updateSeatState)
	updateSeatState()
end

-- Bootstrap
local function registerIfPlane(m: Instance)
	if not m:IsA("Model") then return end
	if not isPlaneModel(m) then return end
	if registry[m] then return end
	local pd = initPlane(m)
	if pd then bindPrompt(pd) end
end

for _, d in ipairs(Workspace:GetDescendants()) do
	registerIfPlane(d)
end
Workspace.DescendantAdded:Connect(function(d)
	task.defer(registerIfPlane, d)
end)

-- =======================
-- [REFUEL + FUEL DRAIN - PASSIVE LOOP]
-- =======================
-- This loop runs passively to check for refueling AND fuel drain
RunService.Heartbeat:Connect(function(dt)
	local now = tick()
	for _, pd in pairs(registry) do
		-- Check if plane exists and is in the workspace
		if pd.plane and pd.plane.Parent then

			-- [REFUEL ADDITION]
			stepRefuel(pd, now)

			-- [NEW] FUEL DRAIN (copied from old update function)
			if pd.on and pd.player then
				local extFuel = pd.plane:GetAttribute("FuelRange")
				if extFuel ~= nil then pd.fuelRange = extFuel end

				if pd.throttle > 0 and pd.fuelRange > 0 and dt > 0 then
					local useNow = pd.throttle * pd.cfg.FUEL_CONSUMPTION_RATE * dt
					pd.fuelRange = math.max(0, pd.fuelRange - useNow)
					pd.plane:SetAttribute("FuelRange", pd.fuelRange)
					if pd.fuelRange <= 0 then
						pd.throttle = 0 -- Stop drain
					end
				end

				-- [FIXED] Always send fuel status to client GUI when player is active
				if RE_Throttle and pd.player then
					-- Client doesn't send brake status, so we pass 0
					pcall(function() RE_Throttle:FireClient(pd.player, pd.throttle, 0, pd.fuelRange) end)
				end
			end
		end
	end
end)
-- =======================
-- [END REFUEL ADDITION]
-- =======================

print("✅ UnifiedPlanePhysics v4.2 LOADED (SERVER - Client Physics)")
